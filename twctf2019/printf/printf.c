//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2019 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_1000(void);
void function_1030(int32_t status);
int32_t function_1040_puts(char * s);
int32_t function_1050(char * s);
void function_1060(void);
int64_t * function_1070(int64_t * s, int32_t c, int32_t n);
int32_t function_1080(int32_t fd, int64_t * buf, int32_t nbytes);
int64_t * function_1090(int64_t * dest, int64_t * src, int32_t n);
int32_t function_10a0(struct _IO_FILE * stream, char * buf, int32_t modes, int32_t n);
int16_t ** function_10b0(void);
void function_10c0(int64_t * d);
int64_t function_1100(void);
int64_t function_1130(void);
int64_t function_1170(void);
int64_t function_11b0(void);
int64_t function_11b5(void);
int64_t function_130d(void);
int64_t function_136e_printf(char * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t function_295e(int64_t a1);
int64_t function_29d8(int64_t a1);
int64_t function_2a40(int64_t a1, int64_t a2, int64_t a3);
int64_t function_2aa0(void);
int64_t function_2aa4(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x1ba600001bb1;
int64_t g2 = -0x1498000014a1;
int64_t g3 = -0x12cf0000127e;
int64_t g4 = -0xe5900000e08;
int64_t g5 = 0x11b0;
int64_t g6 = 0x1170;
struct _IO_FILE * g7 = NULL;
struct _IO_FILE * g8 = NULL;
struct _IO_FILE * g9 = NULL;
char g10 = 0;
int64_t g11 = 0; // r8
int64_t g12 = 0; // r9
int64_t g13 = 0; // rax
int64_t g14 = 0; // rbp
int64_t g15 = 0; // rcx
int64_t g16 = 0; // rdx
int64_t g17 = 0; // rsi
int32_t g18;
int128_t g19 = 0; // xmm0
int128_t g20 = 0; // xmm1
int128_t g21 = 0; // xmm2
int128_t g22 = 0; // xmm3
int128_t g23 = 0; // xmm4
int128_t g24 = 0; // xmm5
int128_t g25 = 0; // xmm6
int128_t g26 = 0; // xmm7

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x1017
int64_t function_1000(void) {
    // 0x1000
    int64_t result; // 0x1016
    if (*(int64_t *)0x4fe8 != 0) {
        // 0x1010
        __gmon_start__();
        result = &g18;
    } else {
        result = 0;
    }
    // 0x1012
    return result;
}

// Address range: 0x1030 - 0x1036
void function_1030(int32_t status) {
    // 0x1030
    _exit(status);
}

// Address range: 0x1040 - 0x1046
int32_t function_1040_puts(char * s) {
    // 0x1040
    return puts(s);
}

// Address range: 0x1050 - 0x1056
int32_t function_1050(char * s) {
    // 0x1050
    return strlen(s);
}

// Address range: 0x1060 - 0x1066
void function_1060(void) {
    // 0x1060
    __stack_chk_fail();
}

// Address range: 0x1070 - 0x1076
int64_t * function_1070(int64_t * s, int32_t c, int32_t n) {
    // 0x1070
    return memset(s, c, n);
}

// Address range: 0x1080 - 0x1086
int32_t function_1080(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x1080
    return read(fd, buf, nbytes);
}

// Address range: 0x1090 - 0x1096
int64_t * function_1090(int64_t * dest, int64_t * src, int32_t n) {
    // 0x1090
    return memcpy(dest, src, n);
}

// Address range: 0x10a0 - 0x10a6
int32_t function_10a0(struct _IO_FILE * stream, char * buf, int32_t modes, int32_t n) {
    // 0x10a0
    return setvbuf(stream, buf, modes, n);
}

// Address range: 0x10b0 - 0x10b6
int16_t ** function_10b0(void) {
    // 0x10b0
    return __ctype_b_loc();
}

// Address range: 0x10c0 - 0x10c6
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10fb
int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x10d0
    int64_t v1;
    __libc_start_main(0x11b5, (int32_t)a4, (char **)&v1, (void (*)())0x2a40, (void (*)())0x2aa0, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1100 - 0x1129
int64_t function_1100(void) {
    // 0x1100
    return 0x5010;
}

// Address range: 0x1130 - 0x1169
int64_t function_1130(void) {
    // 0x1168
    return 0;
}

// Address range: 0x1170 - 0x11a9
int64_t function_1170(void) {
    // 0x1170
    if (g10 != 0) {
        // 0x11a8
        int64_t result; // rax
        return result;
    }
    if (*(int64_t *)0x4ff8 != 0) {
        // 0x1187
        __cxa_finalize((int64_t *)*(int64_t *)0x5008);
    }
    // 0x1193
    g10 = 1;
    return function_1100();
}

// Address range: 0x11b0 - 0x11b5
int64_t function_11b0(void) {
    // 0x11b0
    return function_1130();
}

// main function
// Address range: 0x11b5 - 0x130d
int64_t function_11b5(void) {
    int64_t v1 = __readfsqword(40); // 0x11c0
    function_130d();
    g13 = 0;
    int64_t v2; // r8
    int64_t v3; // r9
    function_136e_printf("What's your name?", g17, g16, g15, v2, v3);
    int64_t buf; // bp-280
    int64_t v4 = &buf; // 0x11e5
    uint32_t v5 = read(0, &buf, 256) - 1; // 0x120a
    *(char *)((int64_t)v5 - 272 + g14) = 0;
    int64_t v6; // 0x1228
    if (v5 > 0) {
        int32_t v7 = 0;
        while (true) {
            // 0x1223
            v6 = *(int64_t *)__ctype_b_loc();
            int64_t v8 = 2 * (int64_t)*(char *)((int64_t)v7 - 272 + g14) + v6; // 0x1242
            int32_t v9 = v7 + 1; // 0x125e
            if (((int32_t)*(int16_t *)v8 & 0x4000) == 0) {
                // break -> 0x1254
                break;
            }
            // 0x1265
            if (v9 >= v5) {
                goto lab_0x1276;
            }
            v7 = v9;
        }
        // 0x1254
        _exit(1);
        // UNREACHABLE
    }
    // 0x11b5
    v6 = 256;
  lab_0x1276:
    // 0x1276
    g13 = 0;
    function_136e_printf("Hi, ", v4, v6, g15, g11, g12);
    g13 = 0;
    function_136e_printf((char *)&buf, v4, g16, g15, g11, g12);
    g13 = 0;
    function_136e_printf("Do you leave a comment?", v4, g16, g15, g11, g12);
    *(char *)(g14 - 272 + (int64_t)(read(0, &buf, 256) - 1)) = 0;
    g13 = 0;
    function_136e_printf((char *)&buf, v4, 256, g15, g11, g12);
    if (__readfsqword(40) == v1) {
        // 0x130b
        return 0;
    }
    // 0x1306
    __stack_chk_fail();
    // 0x130b
    return &g18;
}

// Address range: 0x130d - 0x136e
int64_t function_130d(void) {
    // 0x130d
    setvbuf(g8, NULL, 2, 0);
    setvbuf(g7, NULL, 2, 0);
    g15 = 0;
    g16 = 2;
    g17 = 0;
    return setvbuf(g9, NULL, 2, 0);
}

// own printf function
// Address range: 0x136e - 0x295e
int64_t function_136e_printf(char * fmt, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x136e
    g12 = a6;
    g11 = a5;
    g15 = a4;
    int64_t v1 = (int64_t)fmt; // 0x1379
    if ((char)g13 != 0) {
        // 0x13a7
        __asm_movaps(g19);
        __asm_movaps(g20);
        __asm_movaps(g21);
        __asm_movaps(g22);
        __asm_movaps(g23);
        __asm_movaps(g24);
        __asm_movaps(g25);
        __asm_movaps(g26);
    }
    int64_t v2 = __readfsqword(40); // 0x13c7
    int64_t v3; // bp-184
    int64_t v4 = &v3; // 0x1403
    int64_t v5 = 0;
    int64_t v6 = 0;
    int64_t v7;
    int64_t v8;
    int64_t v9;
    while (true) {
      lab_0x1c25:
        // 0x1c25
        g16 = v6;
        // v1: fmt_ptr
        // v6: loop
        char * v10 = (char *)(v6 + v1); // 0x1c36
        if (*v10 == 0) {
            // break -> 0x1c41
            break;
        }
        // 0x1421
        g16 = v6;
        if (*v10 != 37) { // != %
            // 0x1c01
            v8 = v6; // index of %
            v9 = v5 + 1;
            goto lab_0x1c11;
        } else { // == %
            int64_t v11 = v6 + 1; // 0x143d, loop + 1
            int64_t v12 = v11 + v1; // 0x1474, fmt_ptr + loop + 1
            char * v13 = (char *)v12; // 0x1477, fmt_ptr + loop + 1

            // assign the char after %
            // *(fmt_ptr + loop + 1)
            unsigned char v14 = *v13; // 0x1477
            uint32_t v15 = (int32_t)v14 - 32; // 0x147d
            if (v14 == 45 || v15 < 13) {
                uint32_t v16 = *(int32_t *)(4 * (int64_t)v15 + (int64_t)&g1); // 0x1496
                g16 = &g1;
                return (int64_t)v16 + (int64_t)&g1;
            }
            // 0x14b1
            int64_t v17; // v17??
            if (*v13 > 47) {
                // 0x14c9
                if (*v13 <= 57) { // *v13 is a digit
                    int64_t v18 = function_295e(v12); // 0x14f5
                    int64_t v19 = function_29d8(v12); // 0x1515
                    g16 = v19;
                    if (v18 < 0) {
                        // 0x1538
                        _exit(1);
                        // UNREACHABLE
                    }
                    v17 = v19 + v11;
                } else {
                    v17 = v11;
                }
            } else {
                v17 = v11;
            }
            // v17: offset to the pointer to after the %\d*(p)
            // 0x1542
            g16 = v17;
            unsigned char v20 = *(char *)(v17 + v1); // 0x1553
            if (v20 == 106) { // die if 'j'
              lab_0x161f:
                // 0x161f
                _exit(1);
                // UNREACHABLE
            }
            if (v20 > 106) {
                switch (v20) {
                    case 116: {
                        goto lab_0x161f;
                    }
                    case 122: {
                        goto lab_0x161f;
                    }
                    case 108: { // 'l'
                        int64_t v21 = v17 + 1; // 0x15df
                        // v7 point to the character after 'l' or 'll'
                        v7 = *(char *)(v21 + v1) != 108 ? v21 : v17 + 2;
                        goto lab_0x162d;
                    }
                    default: {
                        v7 = v17;
                        goto lab_0x162d;
                    }
                }
            } else {
                switch (v20) {
                    case 76: {
                        goto lab_0x161f;
                    }
                    case 104: {
                        int64_t v22 = v17 + 1; // 0x159f
                        v7 = *(char *)(v22 + v1) != 104 ? v22 : v17 + 2;
                        goto lab_0x162d;
                    }
                    case 46: {
                        goto lab_0x161f;
                    }
                    default: {
                        v7 = v17;
                        goto lab_0x162d;
                    }
                }
            }
        }
    }
    if (v5 < -1) {
        // 0x1c53
        _exit(1);
        // UNREACHABLE
    }
    uint64_t v23 = v5 + 24; // 0x1c71
    int64_t str2 = 15 + v23 % 16 - v23 & -16; // 0x1c8f
    char * v24 = (char *)v1; // 0x2912255264
    int64_t v25;
    int64_t v26;
    int32_t v27;
    int32_t v28;
    int64_t v29;
    char * v30;
    int64_t v31;
    int64_t v32;
    int64_t puts_rc;
    if (*v24 != 0) {
        v30 = NULL;
        v32 = 0;
        int64_t v33;
        v26 = &v33;
        v28 = 8;
        while (true) {
          lab_0x1ce6:;
            char * v34 = v24; // 0x2912263
            char * v35 = v30;
            int64_t v36 = v32;
            while (true) {
                // 0x1ce6
                if (*v34 == 37) {
                    // break -> 0x1d02
                    break;
                }
                // 0x28ca
                g15 = str2;
                int64_t v37 = (int64_t)v35; // 0x28e2
                *(char *)(v37 + str2) = *v34;
                int64_t v38 = v36 + 1; // 0x28f9
                char * v39 = (char *)(v38 + v1); // 0x2912
                if (*v39 == 0) {
                    // break (via goto) -> 0x291d
                    goto lab_0x291d_2;
                }
                v34 = v39;
                v35 = (char *)(v37 + 1);
                v36 = v38;
            }
            int64_t v40 = v36 + 1; // 0x1d02
            int64_t v41 = v40 + v1; // 0x1d43
            char * v42 = (char *)v41; // 0x1d46
            int64_t v43; // 0x1d88
            int64_t v44; // 0x1da6
            if (*v42 > 47) {
                // 0x1d4d
                if (*v42 <= 57) {
                    // 0x1d65
                    v43 = function_29d8(v41) + v40;
                    v44 = function_295e(v43 + v1);
                } else {
                    v43 = v40;
                    v44 = 0;
                }
            } else {
                v43 = v40;
                v44 = 0;
            }
            // 0x1db2
            switch (*(char *)(v43 + v1)) {
                case 104: {
                    // break -> 0x1e5c
                    break;
                }
                case 108: {
                    // break -> 0x1e5c
                    break;
                }
            }
            v31 = v43;
            // 0x1e5c
            g16 = v31;
            unsigned char v45 = *(char *)(v31 + v1); // 0x1e6d
            if (v45 == 99) {
                int64_t v46 = v28; // 0x2739
                int64_t v47;
                int32_t v48;
                int64_t v49; // 0x2779
                if (v28 < 48) {
                    // 0x2744
                    v47 = v26;
                    v49 = v46 + v4;
                    v48 = v28 + 8;
                } else {
                    // 0x2767
                    v47 = v26 + 8;
                    v49 = v26;
                    v48 = v28;
                }
                // 0x2779
                char * v50;
                if (v44 > 0) {
                    int64_t v51 = v44 - 1; // 0x2792
                    g15 = v51;
                    int64_t v52 = (int64_t)v35; // 0x27a0
                    memset((int64_t *)(v52 + str2), 32, (int32_t)v51);
                    v50 = (char *)(v52 - 1 + v44);
                } else {
                    v50 = v35;
                }
                int64_t v53 = (int64_t)v50; // 0x27dd
                *(char *)(v53 + str2) = (char)*(int32_t *)v49;
                v27 = v48;
                v25 = v47;
                v29 = v53 + 1;
                goto lab_0x28c0;
            } else {
                if (v45 > 99) {
                    switch (v45) {
                        case 115: {
                            int64_t v54 = v28; // 0x27fd
                            int64_t v55;
                            int32_t v56;
                            int64_t v57; // 0x283d
                            if (v28 < 48) {
                                // 0x2808
                                v55 = v26;
                                v57 = v54 + v4;
                                v56 = v28 + 8;
                            } else {
                                // 0x282b
                                v55 = v26 + 8;
                                v57 = v26;
                                v56 = v28;
                            }
                            int64_t v58 = *(int64_t *)v57; // 0x283d
                            char * str = (char *)v58; // 0x284e
                            int64_t v59 = (int64_t)v35; // 0x2860
                            int64_t v60 = v59 + str2; // 0x2867
                            g15 = v60;
                            memcpy((int64_t *)v60, (int64_t *)v58, strlen(str));
                            int64_t len = strlen(str); // 0x288a
                            v27 = v56;
                            v25 = v55;
                            v29 = len + v59;
                            goto lab_0x28c0;
                        }
                        case 120: {
                            goto lab_0x233d;
                        }
                        default: {
                            if (v45 == 100) {
                                // 0x1eb3
                                int64_t v61;
                                uint32_t v62 = *(int32_t *)(v61 + (int64_t)&g3); // 0x1ed7
                                g16 = &g3;
                                int64_t result = (int64_t)v62 + (int64_t)&g3; // 0x1ee3
                                return result;
                            }
                            puts_rc = 0xffffffff;
                            goto lab_0x2945;
                        }
                    }
                } else {
                    switch (v45) {
                        case 37: {
                            int64_t v63 = (int64_t)v35; // 0x289f
                            *(char *)(v63 + str2) = 37;
                            v27 = v28;
                            v25 = v26;
                            v29 = v63 + 1;
                            goto lab_0x28c0;
                        }
                        case 88: {
                            goto lab_0x233d;
                        }
                        default: {
                            puts_rc = 0xffffffff;
                            goto lab_0x2945;
                        }
                    }
                }
            }
        }
    }
  lab_0x291d_2:
    // 0x291d
    g16 = v5;
    *(char *)(str2 + v5) = 0;
    puts_rc = puts((char *)str2);
    goto lab_0x2945;
  lab_0x28c0:;
    int64_t v67 = v31 + 1; // 0x28c0
    char * v68 = (char *)(v67 + v1); // 0x2912255
    if (*v68 == 0) {
        // break -> 0x291d
        goto lab_0x291d_2;
    }
    v24 = v68;
    v30 = (char *)v29;
    v32 = v67;
    v26 = v25;
    v28 = v27;
    goto lab_0x1ce6;
  lab_0x233d:;
    uint32_t v69 = *(int32_t *)(16 + (int64_t)&g4); // 0x2361
    g16 = &g4;
    return (int64_t)v69 + (int64_t)&g4;
  lab_0x2945:;
    // 0x2945
    int64_t result2; // 0x295d
    if (__readfsqword(40) == v2) {
        // 0x2945
        result2 = puts_rc;
    } else {
        // 0x2957
        __stack_chk_fail();
        result2 = &g18;
    }
    // 0x295c
    return result2;
  lab_0x1c11:
    // 0x1c11
    if (v9 < 0) {
        // 0x1c1b
        _exit(1);
        // UNREACHABLE
    }
    v5 = v9;
    v6 = v8 + 1;
    goto lab_0x1c25;
  lab_0x162d:
    // 0x162d
    g16 = v7;
    // v7 is the offset to the format character
    unsigned char v64 = *(char *)(v7 + v1); // 0x163e
    uint32_t v65 = (int32_t)v64 - 37; // 0x1644
    if (v64 == 120 || v65 < 83) { // v64 == 'x' || v64 < 'x'
        uint32_t v66 = *(int32_t *)(4 * (int64_t)v65 + (int64_t)&g2); // 0x1661
        g16 = &g2;
        return (int64_t)v66 + (int64_t)&g2;
    }
    v8 = v7;
    v9 = v5;
    goto lab_0x1c11;
}

// Address range: 0x295e - 0x29d8
// a1: pointer to the middle of fmt.
// points to a digit just after the %.
// Return the integer value of numbers following %.
// %123 -> return 123
int64_t function_295e(int64_t a1) {
    char * v1 = (char *)a1; // 0x29b914
    if (*v1 <= 47) { // not a digit
        // 0x29d2
        return 0;
    }
    int64_t v2 = 0;
    int64_t v3 = 0;
    int64_t result;
    while (true) {
        // 0x29c0
        if (*v1 > 57) { // not a digit (above '9')
            result = v3;
            // break -> 0x29d2
            break;
        }
        int64_t v4 = 10 * v3; // 0x2986
        g15 = v4;
        int64_t v5 = v4 - 48 + (int64_t)*v1; // 0x29a1
        int64_t v6 = v2 + 1; // 0x29a9
        char * v7 = (char *)(v6 + a1); // 0x29b9
        if (*v7 <= 47) {
            result = v5;
            // break -> 0x29d2
            break;
        }
        v1 = v7;
        v2 = v6;
        v3 = v5;
    }
    // 0x29d2
    return result;
}

// Address range: 0x29d8 - 0x2a38
int64_t function_29d8(int64_t a1) {
    // 0x29d8
    if (function_295e(a1) == 0) {
        // 0x2a36
        return 1;
    }
    int64_t result = 1; // 0x2a26
    // 0x2a36
    return result;
}

// Address range: 0x2a40 - 0x2a9d
int64_t function_2a40(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = function_1000(); // 0x2a68
    if (((int64_t)&g6 - (int64_t)&g5) / 8 != 0) {
        int64_t v1 = 0; // 0x2a852
        while (v1 + 1 != ((int64_t)&g6 - (int64_t)&g5) / 8) {
            // 0x2a78
            v1++;
        }
    }
    // 0x2a8e
    return result;
}

// Address range: 0x2aa0 - 0x2aa1
int64_t function_2aa0(void) {
    // 0x2aa0
    int64_t result; // rax
    return result;
}

// Address range: 0x2aa4 - 0x2aad
int64_t function_2aa4(void) {
    // 0x2aa4
    int64_t result; // rax
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// void __cxa_finalize(void * d);
// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void __stack_chk_fail(void);
// void _exit(int status);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int puts(const char * s);
// ssize_t read(int fd, void * buf, size_t nbytes);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (8.3.0)
// Detected functions: 24
// Decompilation date: 2019-09-01 14:18:24
